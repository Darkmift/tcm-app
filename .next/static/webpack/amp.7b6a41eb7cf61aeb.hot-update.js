"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("amp",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\n\nvar _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js */ \"./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js\");\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _asyncToGenerator = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator.js\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\n\nfunction _export(target, all) {\n  for (var name in all) {\n    Object.defineProperty(target, name, {\n      enumerable: true,\n      get: all[name]\n    });\n  }\n}\n\n_export(exports, {\n  \"default\": function _default() {\n    return Router;\n  },\n  matchesMiddleware: function matchesMiddleware() {\n    return _matchesMiddleware;\n  },\n  createKey: function createKey() {\n    return _createKey;\n  }\n});\n\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\n\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\n\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\n\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\n\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\n\nvar _iserror = /*#__PURE__*/_interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\n\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\n\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\n\nvar _mitt = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\n\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\n\nvar _resolverewrites = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\n\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\n\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\n\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\n\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\n\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\n\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\n\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\n\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\n\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\n\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\n\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\n\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\n\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\n\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\n\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\n\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\n\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\n\nvar _resolvehref = __webpack_require__(/*! ./utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\n\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\n\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\n\nfunction buildCancellationError() {\n  return Object.assign(new Error(\"Route Cancelled\"), {\n    cancelled: true\n  });\n}\n\nfunction _matchesMiddleware(_x) {\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction _matchesMiddleware2() {\n  _matchesMiddleware2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(options) {\n    var matchers, _ref6, asPathname, cleanedAs, asWithBasePathAndLocale;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return Promise.resolve(options.router.pageLoader.getMiddleware());\n\n          case 2:\n            matchers = _context8.sent;\n\n            if (matchers) {\n              _context8.next = 5;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", false);\n\n          case 5:\n            _ref6 = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref6.pathname; // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n\n            cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n            asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale)); // Check only path match on client. Matching \"has\" should be done on server\n            // where we can access more info such as headers, HttpOnly cookie, etc.\n\n            return _context8.abrupt(\"return\", matchers.some(function (m) {\n              return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n            }));\n\n          case 9:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction stripOrigin(url) {\n  var origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  var _ref = (0, _resolvehref.resolveHref)(router, url, true),\n      _ref2 = _slicedToArray(_ref, 2),\n      resolvedHref = _ref2[0],\n      resolvedAs = _ref2[1];\n\n  var origin = (0, _utils.getLocationOrigin)();\n  var hrefWasAbsolute = resolvedHref.startsWith(origin);\n  var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n\n  if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(function (page) {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\n\nfunction getMiddlewareData(source, response, options) {\n  var nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(false)\n  };\n  var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n  var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n  var matchedPath = response.headers.get(\"x-matched-path\");\n\n  if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith(\"/\") || undefined) {\n      var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      });\n      var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(function (param) {\n        var _param = _slicedToArray(param, 2),\n            pages = _param[0],\n            rewrites = _param[1].__rewrites;\n\n        var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n\n        if (false) { var result; } else if (!pages.includes(fsPathname)) {\n          var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n\n        var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n\n        return {\n          type: \"rewrite\",\n          parsedAs: parsedRewriteTarget,\n          resolvedHref: resolvedHref\n        };\n      });\n    }\n\n    var src = (0, _parsepath.parsePath)(source);\n    var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n      nextConfig: nextConfig,\n      parseData: true\n    })), {}, {\n      defaultLocale: options.router.defaultLocale,\n      buildId: \"\"\n    }));\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: \"\" + pathname + src.query + src.hash\n    });\n  }\n\n  var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n\n  if (redirectTarget) {\n    if (redirectTarget.startsWith(\"/\")) {\n      var _src = (0, _parsepath.parsePath)(redirectTarget);\n\n      var _pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(_src.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      })), {}, {\n        defaultLocale: options.router.defaultLocale,\n        buildId: \"\"\n      }));\n\n      return Promise.resolve({\n        type: \"redirect-internal\",\n        newAs: \"\" + _pathname + _src.query + _src.hash,\n        newUrl: \"\" + _pathname + _src.query + _src.hash\n      });\n    }\n\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: redirectTarget\n    });\n  }\n\n  return Promise.resolve({\n    type: \"next\"\n  });\n}\n\nfunction withMiddlewareEffects(_x2) {\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nfunction _withMiddlewareEffects() {\n  _withMiddlewareEffects = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(options) {\n    var matches, data, effect;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return _matchesMiddleware(options);\n\n          case 2:\n            matches = _context9.sent;\n\n            if (!(!matches || !options.fetchData)) {\n              _context9.next = 5;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", null);\n\n          case 5:\n            _context9.prev = 5;\n            _context9.next = 8;\n            return options.fetchData();\n\n          case 8:\n            data = _context9.sent;\n            _context9.next = 11;\n            return getMiddlewareData(data.dataHref, data.response, options);\n\n          case 11:\n            effect = _context9.sent;\n            return _context9.abrupt(\"return\", {\n              dataHref: data.dataHref,\n              json: data.json,\n              response: data.response,\n              text: data.text,\n              cacheKey: data.cacheKey,\n              effect: effect\n            });\n\n          case 15:\n            _context9.prev = 15;\n            _context9.t0 = _context9[\"catch\"](5);\n            return _context9.abrupt(\"return\", null);\n\n          case 18:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[5, 15]]);\n  }));\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\n\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` won’t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: \"same-origin\",\n    method: options.method || \"GET\",\n    headers: Object.assign({}, options.headers, {\n      \"x-nextjs-data\": \"1\"\n    })\n  }).then(function (response) {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\n\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction fetchNextData(param) {\n  var dataHref = param.dataHref,\n      inflightCache = param.inflightCache,\n      isPrefetch = param.isPrefetch,\n      hasMiddleware = param.hasMiddleware,\n      isServerRender = param.isServerRender,\n      parseJSON = param.parseJSON,\n      persistCache = param.persistCache,\n      isBackground = param.isBackground,\n      unstable_skipClientCache = param.unstable_skipClientCache;\n\n  var _URL = new URL(dataHref, window.location.href),\n      cacheKey = _URL.href;\n\n  var _params_method;\n\n  var getData = function getData(params) {\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign({}, isPrefetch ? {\n        purpose: \"prefetch\"\n      } : {}, isPrefetch && hasMiddleware ? {\n        \"x-middleware-prefetch\": \"1\"\n      } : {}),\n      method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n    }).then(function (response) {\n      if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n        return {\n          dataHref: dataHref,\n          response: response,\n          text: \"\",\n          json: {},\n          cacheKey: cacheKey\n        };\n      }\n\n      return response.text().then(function (text) {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref: dataHref,\n              response: response,\n              text: text,\n              json: {},\n              cacheKey: cacheKey\n            };\n          }\n\n          if (response.status === 404) {\n            var _tryToParseAsJSON;\n\n            if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n              return {\n                dataHref: dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response: response,\n                text: text,\n                cacheKey: cacheKey\n              };\n            }\n          }\n\n          var error = new Error(\"Failed to load static props\");\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n\n          if (!isServerRender) {\n            (0, _routeloader.markAssetError)(error);\n          }\n\n          throw error;\n        }\n\n        return {\n          dataHref: dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response: response,\n          text: text,\n          cacheKey: cacheKey\n        };\n      });\n    }).then(function (data) {\n      if (!persistCache || true || 0) {\n        delete inflightCache[cacheKey];\n      }\n\n      return data;\n    })[\"catch\"](function (err) {\n      if (!unstable_skipClientCache) {\n        delete inflightCache[cacheKey];\n      }\n\n      if ( // chrome\n      err.message === \"Failed to fetch\" || // firefox\n      err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n      err.message === \"Load failed\") {\n        (0, _routeloader.markAssetError)(err);\n      }\n\n      throw err;\n    });\n  }; // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n\n\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(function (data) {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: \"HEAD\"\n  } : {});\n}\n\nfunction _createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\n\nfunction handleHardNavigation(param) {\n  var url = param.url,\n      router = param.router; // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n  }\n\n  window.location.href = url;\n}\n\nvar getCancelledHandler = function getCancelledHandler(param) {\n  var route = param.route,\n      router = param.router;\n  var cancelled = false;\n\n  var cancel = router.clc = function () {\n    cancelled = true;\n  };\n\n  var handleCancelled = function handleCancelled() {\n    if (cancelled) {\n      var error = new Error('Abort fetching component for route: \"' + route + '\"');\n      error.cancelled = true;\n      throw error;\n    }\n\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n\n  return handleCancelled;\n};\n\nvar Router = /*#__PURE__*/function () {\n  function Router(pathname, query, as, _ref3) {\n    var _this = this;\n\n    var initialProps = _ref3.initialProps,\n        pageLoader = _ref3.pageLoader,\n        App = _ref3.App,\n        wrapApp = _ref3.wrapApp,\n        Component = _ref3.Component,\n        err = _ref3.err,\n        subscription = _ref3.subscription,\n        isFallback = _ref3.isFallback,\n        locale = _ref3.locale,\n        locales = _ref3.locales,\n        defaultLocale = _ref3.defaultLocale,\n        domainLocales = _ref3.domainLocales,\n        isPreview = _ref3.isPreview;\n\n    _classCallCheck(this, Router);\n\n    // Server Data Cache (full data requests)\n    this.sdc = {}; // Server Background Cache (HEAD requests)\n\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = _createKey();\n\n    this.onPopState = function (e) {\n      var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n      _this.isFirstPopStateEvent = false;\n      var state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        var _pathname2 = _this.pathname,\n            _query = _this.query;\n\n        _this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(_pathname2),\n          query: _query\n        }), (0, _utils.getURL)());\n\n        return;\n      } // __NA is used to identify if the history entry can be handled by the app-router.\n\n\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      } // Safari fires popstateevent when reopening the browser.\n\n\n      if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n        return;\n      }\n\n      var forcedScroll;\n      var url = state.url,\n          as = state.as,\n          options = state.options,\n          key = state.key;\n\n      if (false) { var v; }\n\n      _this._key = key;\n\n      var _ref4 = (0, _parserelativeurl.parseRelativeUrl)(url),\n          pathname = _ref4.pathname; // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n\n      if (_this.isSsr && as === (0, _addbasepath.addBasePath)(_this.asPath) && pathname === (0, _addbasepath.addBasePath)(_this.pathname)) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (_this._bps && !_this._bps(state)) {\n        return;\n      }\n\n      _this.change(\"replaceState\", url, as, Object.assign({}, options, {\n        shallow: options.shallow && _this._shallow,\n        locale: options.locale || _this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    var route = (0, _removetrailingslash.removeTrailingSlash)(pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname !== \"/_error\") {\n      this.components[route] = {\n        Component: Component,\n        initial: true,\n        props: initialProps,\n        err: err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n\n    this.components[\"/_app\"] = {\n      Component: App,\n      styleSheets: []\n    };\n\n    if (true) {\n      var _require = __webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter/index.js\"),\n          BloomFilter = _require.BloomFilter;\n\n      var staticFilterData = {\"bitset\":{\"size\":0,\"content\":\"\"},\"hashes\":null,\"size\":0};\n      var dynamicFilterData = {\"bitset\":{\"size\":0,\"content\":\"\"},\"hashes\":null,\"size\":0};\n\n      if (staticFilterData == null ? void 0 : staticFilterData.hashes) {\n        this._bfl_s = new BloomFilter(staticFilterData.size, staticFilterData.hashes);\n\n        this._bfl_s[\"import\"](staticFilterData);\n      }\n\n      if (dynamicFilterData == null ? void 0 : dynamicFilterData.hashes) {\n        this._bfl_d = new BloomFilter(dynamicFilterData.size, dynamicFilterData.hashes);\n\n        this._bfl_d[\"import\"](dynamicFilterData);\n      }\n    } // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.basePath =  false || \"\";\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n\n    if (false) {}\n\n    this.state = {\n      route: route,\n      pathname: pathname,\n      query: query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale:  false ? 0 : undefined,\n      isFallback: isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n\n    if (true) {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith(\"//\")) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        var options = {\n          locale: locale\n        };\n        var asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = _matchesMiddleware({\n          router: this,\n          locale: locale,\n          asPath: asPath\n        }).then(function (matches) {\n          options._shouldResolveHref = as !== pathname;\n\n          _this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query: query\n          }), asPath, options);\n\n          return matches;\n        });\n      }\n\n      window.addEventListener(\"popstate\", this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (false) {}\n    }\n  }\n\n  _createClass(Router, [{\n    key: \"reload\",\n    value: function reload() {\n      window.location.reload();\n    }\n    /**\n    * Go back in history\n    */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n    }\n    /**\n    * Go forward in history\n    */\n\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      window.history.forward();\n    }\n    /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"push\",\n    value: function push(url, as, options) {\n      if (options === void 0) options = {};\n\n      if (false) {}\n\n      var _prepareUrlAs = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs.url;\n      as = _prepareUrlAs.as;\n      return this.change(\"pushState\", url, as, options);\n    }\n    /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(url, as, options) {\n      if (options === void 0) options = {};\n\n      var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs2.url;\n      as = _prepareUrlAs2.as;\n      return this.change(\"replaceState\", url, as, options);\n    }\n  }, {\n    key: \"_bfl\",\n    value: function () {\n      var _bfl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(as, resolvedAs, locale, skipNavigate) {\n        var matchesBflStatic, matchesBflDynamic, _i, _arr, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i2, _arr2, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (false) {}\n\n                matchesBflStatic = false;\n                matchesBflDynamic = false;\n                _i = 0, _arr = [as, resolvedAs];\n\n              case 4:\n                if (!(_i < _arr.length)) {\n                  _context.next = 35;\n                  break;\n                }\n\n                curAs = _arr[_i];\n\n                if (!curAs) {\n                  _context.next = 32;\n                  break;\n                }\n\n                asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n\n                if (!(asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname))) {\n                  _context.next = 32;\n                  break;\n                }\n\n                matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.has(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.has(asNoSlashLocale));\n                _i2 = 0, _arr2 = [asNoSlash, asNoSlashLocale];\n\n              case 12:\n                if (!(_i2 < _arr2.length)) {\n                  _context.next = 27;\n                  break;\n                }\n\n                normalizedAS = _arr2[_i2];\n                // if any sub-path of as matches a dynamic filter path\n                // it should be hard navigated\n                curAsParts = normalizedAS.split(\"/\");\n                i = 0;\n\n              case 16:\n                if (!(!matchesBflDynamic && i < curAsParts.length + 1)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                currentPart = curAsParts.slice(0, i).join(\"/\");\n\n                if (!(currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.has(currentPart)))) {\n                  _context.next = 21;\n                  break;\n                }\n\n                matchesBflDynamic = true;\n                return _context.abrupt(\"break\", 24);\n\n              case 21:\n                i++;\n                _context.next = 16;\n                break;\n\n              case 24:\n                _i2++;\n                _context.next = 12;\n                break;\n\n              case 27:\n                if (!(matchesBflStatic || matchesBflDynamic)) {\n                  _context.next = 32;\n                  break;\n                }\n\n                if (!skipNavigate) {\n                  _context.next = 30;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", true);\n\n              case 30:\n                handleHardNavigation({\n                  url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                  router: this\n                });\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 32:\n                _i++;\n                _context.next = 4;\n                break;\n\n              case 35:\n                return _context.abrupt(\"return\", false);\n\n              case 36:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _bfl(_x3, _x4, _x5, _x6) {\n        return _bfl2.apply(this, arguments);\n      }\n\n      return _bfl;\n    }()\n  }, {\n    key: \"change\",\n    value: function () {\n      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(method, url, as, options, forcedScroll) {\n        var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options$shallow, shallow, _options$scroll, scroll, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, _yield$Promise$all, _yield$Promise$all2, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, rewritesResult, routeMatch, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props, _self___NEXT_DATA___props_pageProps, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, _routeRegex, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, _routeInfo_route, isValidShallowRoute, _options_scroll, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props1, _self___NEXT_DATA___props_pageProps1, _routeInfo_props1, canSkipUpdating, hashRegex;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if ((0, _islocalurl.isLocalURL)(url)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: url,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 3:\n                // WARNING: `_h` is an internal option for handing Next.js client-side\n                // hydration. Your app should _never_ use this property. It may change at\n                // any time without notice.\n                isQueryUpdating = options._h === 1;\n\n                if (!(!isQueryUpdating && !options.shallow)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 7;\n                return this._bfl(as, undefined, options.locale);\n\n              case 7:\n                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n                nextState = _objectSpread({}, this.state); // for static pages with query params in the URL we delay\n                // marking the router ready until after the query is updated\n                // or a navigation has occurred\n\n                readyStateChange = this.isReady !== true;\n                this.isReady = true;\n                isSsr = this.isSsr;\n\n                if (!isQueryUpdating) {\n                  this.isSsr = false;\n                } // if a route transition is already in progress before\n                // the query updating is triggered ignore query updating\n\n\n                if (!(isQueryUpdating && this.clc)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 15:\n                prevLocale = nextState.locale;\n\n                if (true) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n\n                if (typeof options.locale === \"undefined\") {\n                  options.locale = nextState.locale;\n                }\n\n                parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n                localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n\n                if (localePathResult.detectedLocale) {\n                  nextState.locale = localePathResult.detectedLocale;\n                  parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n                  as = (0, _formaturl.formatWithValidation)(parsedAs);\n                  url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);\n                }\n\n                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                if (!didNavigate) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 28:\n                // marking route changes as a navigation start entry\n                if (_utils.ST) {\n                  performance.mark(\"routeChange\");\n                }\n\n                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll;\n                routeProps = {\n                  shallow: shallow\n                };\n\n                if (this._inFlightRoute && this.clc) {\n                  if (!isSsr) {\n                    Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n                  }\n\n                  this.clc();\n                  this.clc = null;\n                }\n\n                as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n                cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n                this._inFlightRoute = as;\n                localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n                // We should not proceed. We should only change the state.\n\n                if (!(!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                  _context2.next = 52;\n                  break;\n                }\n\n                nextState.asPath = cleanedAs;\n                Router.events.emit(\"hashChangeStart\", as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n                this.changeState(method, url, as, _objectSpread(_objectSpread({}, options), {}, {\n                  scroll: false\n                }));\n\n                if (scroll) {\n                  this.scrollToHash(cleanedAs);\n                }\n\n                _context2.prev = 41;\n                _context2.next = 44;\n                return this.set(nextState, this.components[nextState.route], null);\n\n              case 44:\n                _context2.next = 50;\n                break;\n\n              case 46:\n                _context2.prev = 46;\n                _context2.t0 = _context2[\"catch\"](41);\n\n                if ((0, _iserror[\"default\"])(_context2.t0) && _context2.t0.cancelled) {\n                  Router.events.emit(\"routeChangeError\", _context2.t0, cleanedAs, routeProps);\n                }\n\n                throw _context2.t0;\n\n              case 50:\n                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                return _context2.abrupt(\"return\", true);\n\n              case 52:\n                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                pathname = parsed.pathname, query = parsed.query; // if we detected the path as app route during prefetching\n                // trigger hard navigation\n\n                if (!((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter)) {\n                  _context2.next = 57;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 57:\n                _context2.prev = 57;\n                _context2.next = 60;\n                return Promise.all([this.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), this.pageLoader.getMiddleware()]);\n\n              case 60:\n                _yield$Promise$all = _context2.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                pages = _yield$Promise$all2[0];\n                rewrites = _yield$Promise$all2[1].__rewrites;\n                _context2.next = 70;\n                break;\n\n              case 66:\n                _context2.prev = 66;\n                _context2.t1 = _context2[\"catch\"](57);\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 70:\n                // If asked to change the current URL we should reload the current page\n                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                // We also need to set the method = replaceState always\n                // as this should not go into the history (That's how browsers work)\n                // We should compare the new asPath to the current asPath, not the url\n                if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                  method = \"replaceState\";\n                } // we need to resolve the as value using rewrites for dynamic SSG\n                // pages to allow building the data URL correctly\n\n\n                resolvedAs = as; // url and as should always be prefixed with basePath by this\n                // point by either next/link or router.push/replace so strip the\n                // basePath from the pathname to match the pages dir 1-to-1\n\n                pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname))); // we don't attempt resolve asPath when we need to execute\n                // middleware as the resolving will occur server-side\n\n                _context2.t2 = !options.shallow;\n\n                if (!_context2.t2) {\n                  _context2.next = 81;\n                  break;\n                }\n\n                _context2.next = 80;\n                return _matchesMiddleware({\n                  asPath: as,\n                  locale: nextState.locale,\n                  router: this\n                });\n\n              case 80:\n                _context2.t2 = _context2.sent;\n\n              case 81:\n                isMiddlewareMatch = _context2.t2;\n\n                if (isQueryUpdating && isMiddlewareMatch) {\n                  shouldResolveHref = false;\n                }\n\n                if (!(shouldResolveHref && pathname !== \"/_error\")) {\n                  _context2.next = 96;\n                  break;\n                }\n\n                options._shouldResolveHref = true;\n\n                if (true) {\n                  _context2.next = 94;\n                  break;\n                }\n\n                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context2.next = 90;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", true);\n\n              case 90:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = rewritesResult.asPath;\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n                _context2.next = 96;\n                break;\n\n              case 94:\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n                if (parsed.pathname !== pathname) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n              case 96:\n                if ((0, _islocalurl.isLocalURL)(as)) {\n                  _context2.next = 101;\n                  break;\n                }\n\n                if (false) {}\n\n                throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n\n              case 99:\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 101:\n                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                routeMatch = false;\n\n                if (!(0, _isdynamic.isDynamicRoute)(route)) {\n                  _context2.next = 119;\n                  break;\n                }\n\n                parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n                asPathname = parsedAs.pathname;\n                routeRegex = (0, _routeregex.getRouteRegex)(route);\n                routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n                shouldInterpolate = route === asPathname;\n                interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n\n                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                  _context2.next = 118;\n                  break;\n                }\n\n                missingParams = Object.keys(routeRegex.groups).filter(function (param) {\n                  return !query[param] && !routeRegex.groups[param].optional;\n                });\n\n                if (!(missingParams.length > 0 && !isMiddlewareMatch)) {\n                  _context2.next = 116;\n                  break;\n                }\n\n                if (true) {\n                  console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                }\n\n                throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n\n              case 116:\n                _context2.next = 119;\n                break;\n\n              case 118:\n                if (shouldInterpolate) {\n                  as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                  }));\n                } else {\n                  // Merge params into `query`, overwriting any specified in search\n                  Object.assign(query, routeMatch);\n                }\n\n              case 119:\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeStart\", as, routeProps);\n                }\n\n                isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n                _context2.prev = 121;\n                _context2.next = 124;\n                return this.getRouteInfo({\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: routeProps,\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  hasMiddleware: isMiddlewareMatch,\n                  unstable_skipClientCache: options.unstable_skipClientCache,\n                  isQueryUpdating: isQueryUpdating && !this.isFallback,\n                  isMiddlewareRewrite: isMiddlewareRewrite\n                });\n\n              case 124:\n                routeInfo = _context2.sent;\n\n                if (!(!isQueryUpdating && !options.shallow)) {\n                  _context2.next = 128;\n                  break;\n                }\n\n                _context2.next = 128;\n                return this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n\n              case 128:\n                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                  pathname = routeInfo.route || route;\n                  route = pathname;\n\n                  if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                  }\n\n                  cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n\n                  if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach(function (key) {\n                      if (routeMatch && query[key] === routeMatch[key]) {\n                        delete query[key];\n                      }\n                    });\n                  }\n\n                  if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    rewriteAs = prefixedAs;\n\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                      rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n\n                    if (false) {}\n\n                    _routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    curRouteMatch = (0, _routematcher.getRouteMatcher)(_routeRegex)(new URL(rewriteAs, location.href).pathname);\n\n                    if (curRouteMatch) {\n                      Object.assign(query, curRouteMatch);\n                    }\n                  }\n                } // If the routeInfo brings a redirect we simply apply it.\n\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 136;\n                  break;\n                }\n\n                if (!(routeInfo.type === \"redirect-internal\")) {\n                  _context2.next = 134;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.change(method, routeInfo.newUrl, routeInfo.newAs, options));\n\n              case 134:\n                handleHardNavigation({\n                  url: routeInfo.destination,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 136:\n                component = routeInfo.Component;\n\n                if (component && component.unstable_scriptLoader) {\n                  scripts = [].concat(component.unstable_scriptLoader());\n                  scripts.forEach(function (script) {\n                    (0, _script.handleClientScriptLoad)(script.props);\n                  });\n                } // handle redirect on client-transition\n\n\n                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                if (!(routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT)) {\n                  _context2.next = 149;\n                  break;\n                }\n\n                // Use the destination from redirect without adding locale\n                options.locale = false;\n                destination = routeInfo.props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n                // client-navigation if it is falling back to hard navigation if\n                // it's not\n\n                if (!(destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                  _context2.next = 147;\n                  break;\n                }\n\n                parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;\n                return _context2.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n\n              case 147:\n                handleHardNavigation({\n                  url: destination,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 149:\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW; // handle SSG data 404\n\n                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                _context2.prev = 151;\n                _context2.next = 154;\n                return this.fetchComponent(\"/404\");\n\n              case 154:\n                notFoundRoute = \"/404\";\n                _context2.next = 160;\n                break;\n\n              case 157:\n                _context2.prev = 157;\n                _context2.t3 = _context2[\"catch\"](151);\n                notFoundRoute = \"/_error\";\n\n              case 160:\n                _context2.next = 162;\n                return this.getRouteInfo({\n                  route: notFoundRoute,\n                  pathname: notFoundRoute,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  isNotFound: true\n                });\n\n              case 162:\n                routeInfo = _context2.sent;\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on /404\");\n\n              case 165:\n                if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  routeInfo.props.pageProps.statusCode = 500;\n                }\n\n                // shallow routing is only allowed for same page URL changes.\n                isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n                shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n                resetScroll = shouldScroll ? {\n                  x: 0,\n                  y: 0\n                } : null;\n                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll; // the new state that the router gonna set\n\n                upcomingRouterState = _objectSpread(_objectSpread({}, nextState), {}, {\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  asPath: cleanedAs,\n                  isFallback: false\n                }); // When the page being rendered is the 404 page, we should only update the\n                // query parameters. Route changes here might add the basePath when it\n                // wasn't originally present. This is also why this block is before the\n                // below `changeState` call which updates the browser's history (changing\n                // the URL).\n\n                if (!(isQueryUpdating && isErrorRoute)) {\n                  _context2.next = 188;\n                  break;\n                }\n\n                _context2.next = 174;\n                return this.getRouteInfo({\n                  route: this.pathname,\n                  pathname: this.pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n\n              case 174:\n                routeInfo = _context2.sent;\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 177;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n\n              case 177:\n                if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  routeInfo.props.pageProps.statusCode = 500;\n                }\n\n                _context2.prev = 178;\n                _context2.next = 181;\n                return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n              case 181:\n                _context2.next = 187;\n                break;\n\n              case 183:\n                _context2.prev = 183;\n                _context2.t4 = _context2[\"catch\"](178);\n\n                if ((0, _iserror[\"default\"])(_context2.t4) && _context2.t4.cancelled) {\n                  Router.events.emit(\"routeChangeError\", _context2.t4, cleanedAs, routeProps);\n                }\n\n                throw _context2.t4;\n\n              case 187:\n                return _context2.abrupt(\"return\", true);\n\n              case 188:\n                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                this.changeState(method, url, as, options); // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n\n                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n\n                if (canSkipUpdating) {\n                  _context2.next = 211;\n                  break;\n                }\n\n                _context2.prev = 192;\n                _context2.next = 195;\n                return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n              case 195:\n                _context2.next = 204;\n                break;\n\n              case 197:\n                _context2.prev = 197;\n                _context2.t5 = _context2[\"catch\"](192);\n\n                if (!_context2.t5.cancelled) {\n                  _context2.next = 203;\n                  break;\n                }\n\n                routeInfo.error = routeInfo.error || _context2.t5;\n                _context2.next = 204;\n                break;\n\n              case 203:\n                throw _context2.t5;\n\n              case 204:\n                if (!routeInfo.error) {\n                  _context2.next = 207;\n                  break;\n                }\n\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                }\n\n                throw routeInfo.error;\n\n              case 207:\n                if (false) {}\n\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                } // A hash mark # is the optional last part of a URL\n\n\n                hashRegex = /#.+$/;\n\n                if (shouldScroll && hashRegex.test(as)) {\n                  this.scrollToHash(as);\n                }\n\n              case 211:\n                return _context2.abrupt(\"return\", true);\n\n              case 214:\n                _context2.prev = 214;\n                _context2.t6 = _context2[\"catch\"](121);\n\n                if (!((0, _iserror[\"default\"])(_context2.t6) && _context2.t6.cancelled)) {\n                  _context2.next = 218;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 218:\n                throw _context2.t6;\n\n              case 219:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[41, 46], [57, 66], [121, 214], [151, 157], [178, 183], [192, 197]]);\n      }));\n\n      function change(_x7, _x8, _x9, _x10, _x11) {\n        return _change.apply(this, arguments);\n      }\n\n      return change;\n    }()\n  }, {\n    key: \"changeState\",\n    value: function changeState(method, url, as, options) {\n      if (options === void 0) options = {};\n\n      if (true) {\n        if (typeof window.history === \"undefined\") {\n          console.error(\"Warning: window.history is not available.\");\n          return;\n        }\n\n        if (typeof window.history[method] === \"undefined\") {\n          console.error(\"Warning: window.history.\" + method + \" is not available\");\n          return;\n        }\n      }\n\n      if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n        this._shallow = options.shallow;\n        window.history[method]({\n          url: url,\n          as: as,\n          options: options,\n          __N: true,\n          key: this._key = method !== \"pushState\" ? this._key : _createKey()\n        }, // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n        \"\", as);\n      }\n    }\n  }, {\n    key: \"handleRouteInfoError\",\n    value: function () {\n      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(err, pathname, query, as, routeProps, loadErrorFail) {\n        var props, _yield$this$fetchComp, Component, styleSheets, routeInfo;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                console.error(err);\n\n                if (!err.cancelled) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw err;\n\n              case 3:\n                if (!((0, _routeloader.isAssetError)(err) || loadErrorFail)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                Router.events.emit(\"routeChangeError\", err, as, routeProps); // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                }); // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n\n                throw buildCancellationError();\n\n              case 7:\n                _context3.prev = 7;\n                _context3.next = 10;\n                return this.fetchComponent(\"/_error\");\n\n              case 10:\n                _yield$this$fetchComp = _context3.sent;\n                Component = _yield$this$fetchComp.page;\n                styleSheets = _yield$this$fetchComp.styleSheets;\n                routeInfo = {\n                  props: props,\n                  Component: Component,\n                  styleSheets: styleSheets,\n                  err: err,\n                  error: err\n                };\n\n                if (routeInfo.props) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                _context3.prev = 15;\n                _context3.next = 18;\n                return this.getInitialProps(Component, {\n                  err: err,\n                  pathname: pathname,\n                  query: query\n                });\n\n              case 18:\n                routeInfo.props = _context3.sent;\n                _context3.next = 25;\n                break;\n\n              case 21:\n                _context3.prev = 21;\n                _context3.t0 = _context3[\"catch\"](15);\n                console.error(\"Error in error page `getInitialProps`: \", _context3.t0);\n                routeInfo.props = {};\n\n              case 25:\n                return _context3.abrupt(\"return\", routeInfo);\n\n              case 28:\n                _context3.prev = 28;\n                _context3.t1 = _context3[\"catch\"](7);\n                return _context3.abrupt(\"return\", this.handleRouteInfoError((0, _iserror[\"default\"])(_context3.t1) ? _context3.t1 : new Error(_context3.t1 + \"\"), pathname, query, as, routeProps, true));\n\n              case 31:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[7, 28], [15, 21]]);\n      }));\n\n      function handleRouteInfoError(_x12, _x13, _x14, _x15, _x16, _x17) {\n        return _handleRouteInfoError.apply(this, arguments);\n      }\n\n      return handleRouteInfoError;\n    }()\n  }, {\n    key: \"getRouteInfo\",\n    value: function () {\n      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(param) {\n        var _this2 = this;\n\n        var requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, resolvedRoute, pages, routeInfo, _require2, isValidElementType, wasBailedPrefetch, shouldFetchData, _yield$this$_getData, props, cacheKey;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n                /**\n                * This `route` binding can change if there's a rewrite\n                * so we keep a reference to the original requested route\n                * so we can store the cache for it and avoid re-requesting every time\n                * for shallow routing purposes.\n                */\n\n                route = requestedRoute;\n                _context5.prev = 2;\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: this\n                });\n                existingInfo = this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && this.route === route)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", existingInfo);\n\n              case 7:\n                if (hasMiddleware) {\n                  existingInfo = undefined;\n                }\n\n                cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && false ? 0 : undefined;\n                isBackground = isQueryUpdating;\n                fetchNextDataParams = {\n                  dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                      pathname: pathname,\n                      query: query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? \"/404\" : resolvedAs,\n                    locale: locale\n                  }),\n                  hasMiddleware: true,\n                  isServerRender: this.isSsr,\n                  parseJSON: true,\n                  inflightCache: isBackground ? this.sbc : this.sdc,\n                  persistCache: !isPreview,\n                  isPrefetch: false,\n                  unstable_skipClientCache: unstable_skipClientCache,\n                  isBackground: isBackground\n                };\n\n                if (!(isQueryUpdating && !isMiddlewareRewrite)) {\n                  _context5.next = 15;\n                  break;\n                }\n\n                _context5.t0 = null;\n                _context5.next = 18;\n                break;\n\n              case 15:\n                _context5.next = 17;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData(fetchNextDataParams);\n                  },\n                  asPath: isNotFound ? \"/404\" : resolvedAs,\n                  locale: locale,\n                  router: this\n                })[\"catch\"](function (err) {\n                  // we don't hard error during query updating\n                  // as it's un-necessary and doesn't need to be fatal\n                  // unless it is a fallback route and the props can't\n                  // be loaded\n                  if (isQueryUpdating) {\n                    return null;\n                  }\n\n                  throw err;\n                });\n\n              case 17:\n                _context5.t0 = _context5.sent;\n\n              case 18:\n                data = _context5.t0;\n\n                // when rendering error routes we don't apply middleware\n                // effects\n                if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                  data.effect = undefined;\n                }\n\n                if (isQueryUpdating) {\n                  if (!data) {\n                    data = {\n                      json: self.__NEXT_DATA__.props\n                    };\n                  } else {\n                    data.json = self.__NEXT_DATA__.props;\n                  }\n                }\n\n                handleCancelled();\n\n                if (!((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\")) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", data.effect);\n\n              case 24:\n                if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\")) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                _context5.next = 28;\n                return this.pageLoader.getPageList();\n\n              case 28:\n                pages = _context5.sent;\n\n                if (!(!isQueryUpdating || pages.includes(resolvedRoute))) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                route = resolvedRoute;\n                pathname = data.effect.resolvedHref;\n                query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n                resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname); // Check again the cache with the new destination.\n\n                existingInfo = this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && this.route === route && !hasMiddleware)) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", _objectSpread(_objectSpread({}, existingInfo), {}, {\n                  route: route\n                }));\n\n              case 37:\n                if (!(0, _isapiroute.isAPIRoute)(route)) {\n                  _context5.next = 40;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context5.abrupt(\"return\", new Promise(function () {}));\n\n              case 40:\n                _context5.t1 = cachedRouteInfo;\n\n                if (_context5.t1) {\n                  _context5.next = 45;\n                  break;\n                }\n\n                _context5.next = 44;\n                return this.fetchComponent(route).then(function (res) {\n                  return {\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                  };\n                });\n\n              case 44:\n                _context5.t1 = _context5.sent;\n\n              case 45:\n                routeInfo = _context5.t1;\n\n                if (false) {}\n\n                _require2 = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\"), isValidElementType = _require2.isValidElementType;\n\n                if (isValidElementType(routeInfo.Component)) {\n                  _context5.next = 50;\n                  break;\n                }\n\n                throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n\n              case 50:\n                wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP; // For non-SSG prefetches that bailed before sending data\n                // we clear the cache to fetch full response\n\n                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                  delete this.sdc[data.dataHref];\n                }\n\n                _context5.next = 55;\n                return this._getData( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n                  var dataHref, fetched;\n                  return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          if (!shouldFetchData) {\n                            _context4.next = 8;\n                            break;\n                          }\n\n                          if (!((data == null ? void 0 : data.json) && !wasBailedPrefetch)) {\n                            _context4.next = 3;\n                            break;\n                          }\n\n                          return _context4.abrupt(\"return\", {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                          });\n\n                        case 3:\n                          dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this2.pageLoader.getDataHref({\n                            href: (0, _formaturl.formatWithValidation)({\n                              pathname: pathname,\n                              query: query\n                            }),\n                            asPath: resolvedAs,\n                            locale: locale\n                          });\n                          _context4.next = 6;\n                          return fetchNextData({\n                            dataHref: dataHref,\n                            isServerRender: _this2.isSsr,\n                            parseJSON: true,\n                            inflightCache: wasBailedPrefetch ? {} : _this2.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache: unstable_skipClientCache\n                          });\n\n                        case 6:\n                          fetched = _context4.sent;\n                          return _context4.abrupt(\"return\", {\n                            cacheKey: fetched.cacheKey,\n                            props: fetched.json || {}\n                          });\n\n                        case 8:\n                          _context4.t0 = {};\n                          _context4.next = 11;\n                          return _this2.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                          {\n                            pathname: pathname,\n                            query: query,\n                            asPath: as,\n                            locale: locale,\n                            locales: _this2.locales,\n                            defaultLocale: _this2.defaultLocale\n                          });\n\n                        case 11:\n                          _context4.t1 = _context4.sent;\n                          return _context4.abrupt(\"return\", {\n                            headers: _context4.t0,\n                            props: _context4.t1\n                          });\n\n                        case 13:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                })));\n\n              case 55:\n                _yield$this$_getData = _context5.sent;\n                props = _yield$this$_getData.props;\n                cacheKey = _yield$this$_getData.cacheKey;\n\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                  delete this.sdc[cacheKey];\n                } // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n\n\n                if (!this.isPreview && routeInfo.__N_SSG && false && 0) {}\n\n                props.pageProps = Object.assign({}, props.pageProps);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                this.components[route] = routeInfo;\n                return _context5.abrupt(\"return\", routeInfo);\n\n              case 69:\n                _context5.prev = 69;\n                _context5.t2 = _context5[\"catch\"](2);\n                return _context5.abrupt(\"return\", this.handleRouteInfoError((0, _iserror.getProperError)(_context5.t2), pathname, query, as, routeProps));\n\n              case 72:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[2, 69]]);\n      }));\n\n      function getRouteInfo(_x18) {\n        return _getRouteInfo.apply(this, arguments);\n      }\n\n      return getRouteInfo;\n    }()\n  }, {\n    key: \"set\",\n    value: function set(state, data, resetScroll) {\n      this.state = state;\n      return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n\n  }, {\n    key: \"beforePopState\",\n    value: function beforePopState(cb) {\n      this._bps = cb;\n    }\n  }, {\n    key: \"onlyAHashChange\",\n    value: function onlyAHashChange(as) {\n      if (!this.asPath) return false;\n\n      var _this$asPath$split = this.asPath.split(\"#\"),\n          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),\n          oldUrlNoHash = _this$asPath$split2[0],\n          oldHash = _this$asPath$split2[1];\n\n      var _as$split = as.split(\"#\"),\n          _as$split2 = _slicedToArray(_as$split, 2),\n          newUrlNoHash = _as$split2[0],\n          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same\n\n\n      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n        return true;\n      } // If the urls are change, there's more than a hash change\n\n\n      if (oldUrlNoHash !== newUrlNoHash) {\n        return false;\n      } // If the hash has changed, then it's a hash only change.\n      // This check is necessary to handle both the enter and\n      // leave hash === '' cases. The identity case falls through\n      // and is treated as a next reload.\n\n\n      return oldHash !== newHash;\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash(as) {\n      var _as$split3 = as.split(\"#\"),\n          _as$split4 = _slicedToArray(_as$split3, 2),\n          _as$split4$ = _as$split4[1],\n          hash = _as$split4$ === void 0 ? \"\" : _as$split4$; // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n\n\n      if (hash === \"\" || hash === \"top\") {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return window.scrollTo(0, 0);\n        });\n        return;\n      } // Decode hash to make non-latin anchor works.\n\n\n      var rawHash = decodeURIComponent(hash); // First we check if the element by id is found\n\n      var idEl = document.getElementById(rawHash);\n\n      if (idEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return idEl.scrollIntoView();\n        });\n        return;\n      } // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n\n\n      var nameEl = document.getElementsByName(rawHash)[0];\n\n      if (nameEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return nameEl.scrollIntoView();\n        });\n      }\n    }\n  }, {\n    key: \"urlIsNew\",\n    value: function urlIsNew(asPath) {\n      return this.asPath !== asPath;\n    }\n    /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function () {\n      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(url, asPath, options) {\n        var _this3 = this;\n\n        var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, _yield, rewritesResult, data, route;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (asPath === void 0) asPath = url;\n                if (options === void 0) options = {}; // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n                if (false) {}\n\n                return _context6.abrupt(\"return\");\n\n              case 4:\n                if (!( true && (0, _isbot.isBot)(window.navigator.userAgent))) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 6:\n                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                urlPathname = parsed.pathname;\n                pathname = parsed.pathname, query = parsed.query;\n                originalPathname = pathname;\n\n                if (false) {}\n\n                _context6.next = 13;\n                return this.pageLoader.getPageList();\n\n              case 13:\n                pages = _context6.sent;\n                resolvedAs = asPath;\n                locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n                _context6.next = 18;\n                return _matchesMiddleware({\n                  asPath: asPath,\n                  locale: locale,\n                  router: this\n                });\n\n              case 18:\n                isMiddlewareMatch = _context6.sent;\n\n                if (true) {\n                  _context6.next = 29;\n                  break;\n                }\n\n                _context6.next = 22;\n                return (0, _routeloader.getClientBuildManifest)();\n\n              case 22:\n                _yield = _context6.sent;\n                rewrites = _yield.__rewrites;\n                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context6.next = 27;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 27:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = pathname;\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n              case 29:\n                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n                if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = pathname;\n                  Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n                if (true) {\n                  _context6.next = 35;\n                  break;\n                }\n\n                _context6.t0 = null;\n                _context6.next = 38;\n                break;\n\n              case 35:\n                _context6.next = 37;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData({\n                      dataHref: _this3.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                          pathname: originalPathname,\n                          query: query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale: locale\n                      }),\n                      hasMiddleware: true,\n                      isServerRender: _this3.isSsr,\n                      parseJSON: true,\n                      inflightCache: _this3.sdc,\n                      persistCache: !_this3.isPreview,\n                      isPrefetch: true\n                    });\n                  },\n                  asPath: asPath,\n                  locale: locale,\n                  router: this\n                });\n\n              case 37:\n                _context6.t0 = _context6.sent;\n\n              case 38:\n                data = _context6.t0;\n\n                /**\n                * If there was a rewrite we apply the effects of the rewrite on the\n                * current parameters for the prefetch.\n                */\n                if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                  parsed.pathname = data.effect.resolvedHref;\n                  pathname = data.effect.resolvedHref;\n                  query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n                  resolvedAs = data.effect.parsedAs.pathname;\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n                /**\n                * If there is a redirect to an external destination then we don't have\n                * to prefetch content as it will be unused.\n                */\n\n\n                if (!((data == null ? void 0 : data.effect.type) === \"redirect-external\")) {\n                  _context6.next = 42;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 42:\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                _context6.next = 45;\n                return this._bfl(asPath, resolvedAs, options.locale, true);\n\n              case 45:\n                if (!_context6.sent) {\n                  _context6.next = 47;\n                  break;\n                }\n\n                this.components[urlPathname] = {\n                  __appRouter: true\n                };\n\n              case 47:\n                _context6.next = 49;\n                return Promise.all([this.pageLoader._isSsg(route).then(function (isSsg) {\n                  return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this3.pageLoader.getDataHref({\n                      href: url,\n                      asPath: resolvedAs,\n                      locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: _this3.sdc,\n                    persistCache: !_this3.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                  }).then(function () {\n                    return false;\n                  })[\"catch\"](function () {\n                    return false;\n                  }) : false;\n                }), this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)]);\n\n              case 49:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function prefetch(_x19, _x20, _x21) {\n        return _prefetch.apply(this, arguments);\n      }\n\n      return prefetch;\n    }()\n  }, {\n    key: \"fetchComponent\",\n    value: function () {\n      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(route) {\n        var handleCancelled, componentResult;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: this\n                });\n                _context7.prev = 1;\n                _context7.next = 4;\n                return this.pageLoader.loadPage(route);\n\n              case 4:\n                componentResult = _context7.sent;\n                handleCancelled();\n                return _context7.abrupt(\"return\", componentResult);\n\n              case 9:\n                _context7.prev = 9;\n                _context7.t0 = _context7[\"catch\"](1);\n                handleCancelled();\n                throw _context7.t0;\n\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[1, 9]]);\n      }));\n\n      function fetchComponent(_x22) {\n        return _fetchComponent.apply(this, arguments);\n      }\n\n      return fetchComponent;\n    }()\n  }, {\n    key: \"_getData\",\n    value: function _getData(fn) {\n      var _this4 = this;\n\n      var cancelled = false;\n\n      var cancel = function cancel() {\n        cancelled = true;\n      };\n\n      this.clc = cancel;\n      return fn().then(function (data) {\n        if (cancel === _this4.clc) {\n          _this4.clc = null;\n        }\n\n        if (cancelled) {\n          var err = new Error(\"Loading initial props cancelled\");\n          err.cancelled = true;\n          throw err;\n        }\n\n        return data;\n      });\n    }\n  }, {\n    key: \"_getFlightData\",\n    value: function _getFlightData(dataHref) {\n      // Do not cache RSC flight response since it's not a static resource\n      return fetchNextData({\n        dataHref: dataHref,\n        isServerRender: true,\n        parseJSON: false,\n        inflightCache: this.sdc,\n        persistCache: false,\n        isPrefetch: false\n      }).then(function (param) {\n        var text = param.text;\n        return {\n          data: text\n        };\n      });\n    }\n  }, {\n    key: \"getInitialProps\",\n    value: function getInitialProps(Component, ctx) {\n      var App = this.components[\"/_app\"].Component;\n\n      var AppTree = this._wrapApp(App);\n\n      ctx.AppTree = AppTree;\n      return (0, _utils.loadGetInitialProps)(App, {\n        AppTree: AppTree,\n        Component: Component,\n        router: this,\n        ctx: ctx\n      });\n    }\n  }, {\n    key: \"route\",\n    get: function get() {\n      return this.state.route;\n    }\n  }, {\n    key: \"pathname\",\n    get: function get() {\n      return this.state.pathname;\n    }\n  }, {\n    key: \"query\",\n    get: function get() {\n      return this.state.query;\n    }\n  }, {\n    key: \"asPath\",\n    get: function get() {\n      return this.state.asPath;\n    }\n  }, {\n    key: \"locale\",\n    get: function get() {\n      return this.state.locale;\n    }\n  }, {\n    key: \"isFallback\",\n    get: function get() {\n      return this.state.isFallback;\n    }\n  }, {\n    key: \"isPreview\",\n    get: function get() {\n      return this.state.isPreview;\n    }\n  }]);\n\n  return Router;\n}();\n\n(function () {\n  Router.events = (0, _mitt[\"default\"])();\n})();\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQSxNQUFNQyxDQUFOOztBQUtBLFNBQVNHLE9BQVQsQ0FBaUJDLE1BQWpCLEVBQXlCQyxHQUF6QixFQUE4QjtFQUMxQixLQUFJLElBQUlDLElBQVIsSUFBZ0JELEdBQWhCO0lBQW9CVCxNQUFNLENBQUNDLGNBQVAsQ0FBc0JPLE1BQXRCLEVBQThCRSxJQUE5QixFQUFvQztNQUNwREMsVUFBVSxFQUFFLElBRHdDO01BRXBEQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBRDtJQUY0QyxDQUFwQztFQUFwQjtBQUlIOztBQUNESCxPQUFPLENBQUNMLE9BQUQsRUFBVTtFQUNiLFdBQVMsb0JBQVc7SUFDaEIsT0FBT1csTUFBUDtFQUNILENBSFk7RUFJYlIsaUJBQWlCLEVBQUUsNkJBQVc7SUFDMUIsT0FBT0Esa0JBQVA7RUFDSCxDQU5ZO0VBT2JDLFNBQVMsRUFBRSxxQkFBVztJQUNsQixPQUFPQSxVQUFQO0VBQ0g7QUFUWSxDQUFWLENBQVA7O0FBV0EsSUFBTVEsd0JBQXdCLEdBQUdDLG1CQUFPLENBQUMsNEdBQUQsQ0FBeEM7O0FBQ0EsSUFBTUMseUJBQXlCLEdBQUdELG1CQUFPLENBQUMsOEdBQUQsQ0FBekM7O0FBQ0EsSUFBTUUsb0JBQW9CLEdBQUdGLG1CQUFPLENBQUMsZ0hBQUQsQ0FBcEM7O0FBQ0EsSUFBTUcsWUFBWSxHQUFHSCxtQkFBTyxDQUFDLHFGQUFELENBQTVCOztBQUNBLElBQU1JLE9BQU8sR0FBR0osbUJBQU8sQ0FBQyx5RUFBRCxDQUF2Qjs7QUFDQSxJQUFNSyxRQUFRLEdBQUcsYUFBY0oseUJBQXlCLENBQUNLLENBQTFCLENBQTRCTixtQkFBTyxDQUFDLHVFQUFELENBQW5DLENBQS9COztBQUNB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Li9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcz84Njg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogbnVsbCxcbiAgICBjcmVhdGVLZXk6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSb3V0ZXI7XG4gICAgfSxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzTWlkZGxld2FyZTtcbiAgICB9LFxuICAgIGNyZWF0ZUtleTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVLZXk7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfcm91dGVsb2FkZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlclwiKTtcbmNvbnN0IF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcbmNvbnN0IF9pc2Vycm9yID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG5jb25zdCBfZGVub3JtYWxpemVwYWdlcGF0aCA9IHJlcXVpcmUoXCIuLi9wYWdlLXBhdGgvZGVub3JtYWxpemUtcGFnZS1wYXRoXCIpO1xuY29uc3QgX25vcm1hbGl6ZWxvY2FsZXBhdGggPSByZXF1aXJlKFwiLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL21pdHRcIikpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgX2lzZHluYW1pYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWR5bmFtaWNcIik7XG5jb25zdCBfcGFyc2VyZWxhdGl2ZXVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbmNvbnN0IF9yZXNvbHZlcmV3cml0ZXMgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXNcIikpO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC11cmxcIik7XG5jb25zdCBfZGV0ZWN0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9wYXJzZXBhdGggPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1wYXRoXCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmVsb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGVcIik7XG5jb25zdCBfcmVtb3ZlYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1iYXNlLXBhdGhcIik7XG5jb25zdCBfYWRkYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfaGFzYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfaXNhcGlyb3V0ZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvaXMtYXBpLXJvdXRlXCIpO1xuY29uc3QgX2dldG5leHRwYXRobmFtZWluZm8gPSByZXF1aXJlKFwiLi91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8gPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgX2NvbXBhcmVzdGF0ZXMgPSByZXF1aXJlKFwiLi91dGlscy9jb21wYXJlLXN0YXRlc1wiKTtcbmNvbnN0IF9pc2xvY2FsdXJsID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtbG9jYWwtdXJsXCIpO1xuY29uc3QgX2lzYm90ID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtYm90XCIpO1xuY29uc3QgX29taXQgPSByZXF1aXJlKFwiLi91dGlscy9vbWl0XCIpO1xuY29uc3QgX3Jlc29sdmVocmVmID0gcmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1ocmVmXCIpO1xuY29uc3QgX2ludGVycG9sYXRlYXMgPSByZXF1aXJlKFwiLi91dGlscy9pbnRlcnBvbGF0ZS1hc1wiKTtcbmNvbnN0IF9oYW5kbGVzbW9vdGhzY3JvbGwgPSByZXF1aXJlKFwiLi91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKFwiUm91dGUgQ2FuY2VsbGVkXCIpLCB7XG4gICAgICAgIGNhbmNlbGxlZDogdHJ1ZVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucykge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpKTtcbiAgICBpZiAoIW1hdGNoZXJzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkob3B0aW9ucy5hc1BhdGgpO1xuICAgIC8vIHJlbW92ZSBiYXNlUGF0aCBmaXJzdCBzaW5jZSBwYXRoIHByZWZpeCBoYXMgdG8gYmUgaW4gdGhlIG9yZGVyIG9mIGAvJHtiYXNlUGF0aH0vJHtsb2NhbGV9YFxuICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzUGF0aG5hbWUpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXNQYXRobmFtZSkgOiBhc1BhdGhuYW1lO1xuICAgIGNvbnN0IGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShjbGVhbmVkQXMsIG9wdGlvbnMubG9jYWxlKSk7XG4gICAgLy8gQ2hlY2sgb25seSBwYXRoIG1hdGNoIG9uIGNsaWVudC4gTWF0Y2hpbmcgXCJoYXNcIiBzaG91bGQgYmUgZG9uZSBvbiBzZXJ2ZXJcbiAgICAvLyB3aGVyZSB3ZSBjYW4gYWNjZXNzIG1vcmUgaW5mbyBzdWNoIGFzIGhlYWRlcnMsIEh0dHBPbmx5IGNvb2tpZSwgZXRjLlxuICAgIHJldHVybiBtYXRjaGVycy5zb21lKChtKT0+bmV3IFJlZ0V4cChtLnJlZ2V4cCkudGVzdChhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSkpO1xufVxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKTtcbiAgICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgob3JpZ2luKSA/IHVybC5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCkgOiB1cmw7XG59XG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyLCB1cmwsIGFzKSB7XG4gICAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gICAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgICBsZXQgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShyb3V0ZXIsIHVybCwgdHJ1ZSk7XG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKTtcbiAgICBjb25zdCBocmVmV2FzQWJzb2x1dGUgPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIGNvbnN0IGFzV2FzQWJzb2x1dGUgPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZik7XG4gICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXM7XG4gICAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmV2FzQWJzb2x1dGUgPyByZXNvbHZlZEhyZWYgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShyZXNvbHZlZEhyZWYpO1xuICAgIGNvbnN0IHByZXBhcmVkQXMgPSBhcyA/IHN0cmlwT3JpZ2luKCgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHJvdXRlciwgYXMpKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVybDogcHJlcGFyZWRVcmwsXG4gICAgICAgIGFzOiBhc1dhc0Fic29sdXRlID8gcHJlcGFyZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHByZXBhcmVkQXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKSB7XG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKSgoMCwgX2Rlbm9ybWFsaXplcGFnZXBhdGguZGVub3JtYWxpemVQYWdlUGF0aCkocGF0aG5hbWUpKTtcbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gXCIvNDA0XCIgfHwgY2xlYW5QYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIHBhZ2VzLnNvbWUoKHBhZ2UpPT57XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhZ2UpICYmICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYWdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG59XG5mdW5jdGlvbiBnZXRNaWRkbGV3YXJlRGF0YShzb3VyY2UsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dENvbmZpZyA9IHtcbiAgICAgICAgYmFzZVBhdGg6IG9wdGlvbnMucm91dGVyLmJhc2VQYXRoLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBsb2NhbGVzOiBvcHRpb25zLnJvdXRlci5sb2NhbGVzXG4gICAgICAgIH0sXG4gICAgICAgIHRyYWlsaW5nU2xhc2g6IEJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKVxuICAgIH07XG4gICAgY29uc3QgcmV3cml0ZUhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1uZXh0anMtcmV3cml0ZVwiKTtcbiAgICBsZXQgcmV3cml0ZVRhcmdldCA9IHJld3JpdGVIZWFkZXIgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1tYXRjaGVkLXBhdGhcIik7XG4gICAgY29uc3QgbWF0Y2hlZFBhdGggPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbWF0Y2hlZC1wYXRoXCIpO1xuICAgIGlmIChtYXRjaGVkUGF0aCAmJiAhcmV3cml0ZVRhcmdldCAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCJfX25leHRfZGF0YV9jYXRjaGFsbFwiKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCIvX2Vycm9yXCIpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIi80MDRcIikpIHtcbiAgICAgICAgLy8gbGV2ZXJhZ2UgeC1tYXRjaGVkLXBhdGggdG8gZGV0ZWN0IG5leHQuY29uZmlnLmpzIHJld3JpdGVzXG4gICAgICAgIHJld3JpdGVUYXJnZXQgPSBtYXRjaGVkUGF0aDtcbiAgICB9XG4gICAgaWYgKHJld3JpdGVUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJld3JpdGVUYXJnZXQuc3RhcnRzV2l0aChcIi9cIikgfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRSZXdyaXRlVGFyZ2V0ID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJld3JpdGVUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWVJbmZvID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZnNQYXRobmFtZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZUluZm8ucGF0aG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJvdXRlci5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpXG4gICAgICAgICAgICBdKS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIGxldCBhcyA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGF0aG5hbWVJbmZvLnBhdGhuYW1lLCBwYXRobmFtZUluZm8ubG9jYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKGFzKSB8fCAhcmV3cml0ZUhlYWRlciAmJiBwYWdlcy5pbmNsdWRlcygoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU291cmNlID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKCgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShzb3VyY2UpLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFzID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGFyc2VkU291cmNlLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IGFzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KShhcywgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCAocGF0aCk9PnJlc29sdmVEeW5hbWljUm91dGUocGF0aCwgcGFnZXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tYXRjaGVkUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IHJlc3VsdC5wYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzID0gcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgcmVzdWx0LnBhcnNlZEFzLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKGZzUGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkUGF0aG5hbWUgIT09IGZzUGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzUGF0aG5hbWUgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9ICFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSA/IHJlc29sdmVEeW5hbWljUm91dGUoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSwgcGFnZXMpIDogZnNQYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHJlc29sdmVkSHJlZikpKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCBtYXRjaGVzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZXdyaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzOiBwYXJzZWRSZXdyaXRlVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEhyZWZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShzb3VyY2UpO1xuICAgICAgICBjb25zdCBwYXRobmFtZSA9ICgwLCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mby5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKSh7XG4gICAgICAgICAgICAuLi4oMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgIGJ1aWxkSWQ6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1leHRlcm5hbFwiLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdFRhcmdldCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1uZXh0anMtcmVkaXJlY3RcIik7XG4gICAgaWYgKHJlZGlyZWN0VGFyZ2V0KSB7XG4gICAgICAgIGlmIChyZWRpcmVjdFRhcmdldC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShyZWRpcmVjdFRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZSA9ICgwLCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mby5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKSh7XG4gICAgICAgICAgICAgICAgLi4uKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHNyYy5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgICAgIGJ1aWxkSWQ6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1pbnRlcm5hbFwiLFxuICAgICAgICAgICAgICAgIG5ld0FzOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaCxcbiAgICAgICAgICAgICAgICBuZXdVcmw6IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3QtZXh0ZXJuYWxcIixcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiByZWRpcmVjdFRhcmdldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHR5cGU6IFwibmV4dFwiXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoTWlkZGxld2FyZUVmZmVjdHMob3B0aW9ucykge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKTtcbiAgICBpZiAoIW1hdGNoZXMgfHwgIW9wdGlvbnMuZmV0Y2hEYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgb3B0aW9ucy5mZXRjaERhdGEoKTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gYXdhaXQgZ2V0TWlkZGxld2FyZURhdGEoZGF0YS5kYXRhSHJlZiwgZGF0YS5yZXNwb25zZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhSHJlZjogZGF0YS5kYXRhSHJlZixcbiAgICAgICAgICAgIGpzb246IGRhdGEuanNvbixcbiAgICAgICAgICAgIHJlc3BvbnNlOiBkYXRhLnJlc3BvbnNlLFxuICAgICAgICAgICAgdGV4dDogZGF0YS50ZXh0LFxuICAgICAgICAgICAgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksXG4gICAgICAgICAgICBlZmZlY3RcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qKlxuICAgICAqIFRPRE86IFJldmlzaXQgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEZvciBub3cgd2Ugd2lsbCBub3QgY29uc2lkZXIgbWlkZGxld2FyZSBkYXRhIGVycm9ycyB0byBiZSBmYXRhbC5cbiAgICAgKiBtYXliZSB3ZSBzaG91bGQgcmV2aXNpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAqLyByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcInNjcm9sbFJlc3RvcmF0aW9uXCIgaW4gd2luZG93Lmhpc3RvcnkgJiYgISFmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgdiA9IFwiX19uZXh0XCI7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWU7XG4gICAgfSBjYXRjaCAobikge31cbn0oKTtcbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbChcIlNTR19EQVRBX05PVF9GT1VORFwiKTtcbmZ1bmN0aW9uIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cywgb3B0aW9ucykge1xuICAgIHJldHVybiBmZXRjaCh1cmwsIHtcbiAgICAgICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgICAgICAvL1xuICAgICAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgICAgIC8vID4gb3B0aW9uLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJL1VzaW5nX0ZldGNoXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgICAgIC8vID4gcmVjZWl2aW5nIGNvb2tpZXMsIGFsd2F5cyBzdXBwbHkgdGhlIGBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ2BcbiAgICAgICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICAgICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIixcbiAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICAgIFwieC1uZXh0anMtZGF0YVwiOiBcIjFcIlxuICAgICAgICB9KVxuICAgIH0pLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICByZXR1cm4gIXJlc3BvbnNlLm9rICYmIGF0dGVtcHRzID4gMSAmJiByZXNwb25zZS5zdGF0dXMgPj0gNTAwID8gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSwgb3B0aW9ucykgOiByZXNwb25zZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRyeVRvUGFyc2VBc0pTT04odGV4dCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEocGFyYW0pIHtcbiAgICBsZXQgeyBkYXRhSHJlZiAsIGluZmxpZ2h0Q2FjaGUgLCBpc1ByZWZldGNoICwgaGFzTWlkZGxld2FyZSAsIGlzU2VydmVyUmVuZGVyICwgcGFyc2VKU09OICwgcGVyc2lzdENhY2hlICwgaXNCYWNrZ3JvdW5kICwgdW5zdGFibGVfc2tpcENsaWVudENhY2hlICB9ID0gcGFyYW07XG4gICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSAgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB2YXIgX3BhcmFtc19tZXRob2Q7XG4gICAgY29uc3QgZ2V0RGF0YSA9IChwYXJhbXMpPT57XG4gICAgICAgIHJldHVybiBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBpc1ByZWZldGNoID8ge1xuICAgICAgICAgICAgICAgIHB1cnBvc2U6IFwicHJlZmV0Y2hcIlxuICAgICAgICAgICAgfSA6IHt9LCBpc1ByZWZldGNoICYmIGhhc01pZGRsZXdhcmUgPyB7XG4gICAgICAgICAgICAgICAgXCJ4LW1pZGRsZXdhcmUtcHJlZmV0Y2hcIjogXCIxXCJcbiAgICAgICAgICAgIH0gOiB7fSksXG4gICAgICAgICAgICBtZXRob2Q6IChfcGFyYW1zX21ldGhvZCA9IHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLm1ldGhvZCkgIT0gbnVsbCA/IF9wYXJhbXNfbWV0aG9kIDogXCJHRVRcIlxuICAgICAgICB9KS50aGVuKChyZXNwb25zZSk9PntcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vayAmJiAocGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSA9PT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4oKHRleHQpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gdGhlIGRhdGEgcmVzcG9uc2UgaXMgYSByZWRpcmVjdCBiZWNhdXNlIG9mIGEgbWlkZGxld2FyZVxuICAgICAgICAgICAgICogd2UgZG8gbm90IGNvbnNpZGVyIGl0IGFuIGVycm9yLiBUaGUgaGVhZGVycyBtdXN0IGJyaW5nIHRoZVxuICAgICAgICAgICAgICogbWFwcGVkIGxvY2F0aW9uLlxuICAgICAgICAgICAgICogVE9ETzogQ2hhbmdlIHRoZSBzdGF0dXMgY29kZSBpbiB0aGUgaGFuZGxlci5cbiAgICAgICAgICAgICAqLyBpZiAoaGFzTWlkZGxld2FyZSAmJiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDcsXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDhcbiAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RyeVRvUGFyc2VBc0pTT047XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF90cnlUb1BhcnNlQXNKU09OID0gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cnlUb1BhcnNlQXNKU09OLm5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kOiBTU0dfREFUQV9OT1RfRk9VTkRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhc1xuICAgICAgICAgICAgICogY2F1c2VkIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvXG4gICAgICAgICAgICAgKiBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAgICAgICAgICovIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIubWFya0Fzc2V0RXJyb3IpKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIGpzb246IHBhcnNlSlNPTiA/IHRyeVRvUGFyc2VBc0pTT04odGV4dCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoIXBlcnNpc3RDYWNoZSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgfHwgZGF0YS5yZXNwb25zZS5oZWFkZXJzLmdldChcIngtbWlkZGxld2FyZS1jYWNoZVwiKSA9PT0gXCJuby1jYWNoZVwiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBpZiAoIXVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvLyBjaHJvbWVcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSBcIkZhaWxlZCB0byBmZXRjaFwiIHx8IC8vIGZpcmVmb3hcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSBcIk5ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuXCIgfHwgLy8gc2FmYXJpXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJMb2FkIGZhaWxlZFwiKSB7XG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5tYXJrQXNzZXRFcnJvcikoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB3aGVuIHNraXBwaW5nIGNsaWVudCBjYWNoZSB3ZSB3YWl0IHRvIHVwZGF0ZVxuICAgIC8vIGluZmxpZ2h0IGNhY2hlIHVudGlsIHN1Y2Nlc3NmdWwgZGF0YSByZXNwb25zZVxuICAgIC8vIHRoaXMgYWxsb3dzIHJhY2luZyBjbGljayBldmVudCB3aXRoIGZldGNoaW5nIG5ld2VyIGRhdGFcbiAgICAvLyB3aXRob3V0IGJsb2NraW5nIG5hdmlnYXRpb24gd2hlbiBzdGFsZSBkYXRhIGlzIGF2YWlsYWJsZVxuICAgIGlmICh1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgJiYgcGVyc2lzdENhY2hlKSB7XG4gICAgICAgIHJldHVybiBnZXREYXRhKHt9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gZ2V0RGF0YShpc0JhY2tncm91bmQgPyB7XG4gICAgICAgIG1ldGhvZDogXCJIRUFEXCJcbiAgICB9IDoge30pO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMCk7XG59XG5mdW5jdGlvbiBoYW5kbGVIYXJkTmF2aWdhdGlvbihwYXJhbSkge1xuICAgIGxldCB7IHVybCAsIHJvdXRlciAgfSA9IHBhcmFtO1xuICAgIC8vIGVuc3VyZSB3ZSBkb24ndCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lXG4gICAgLy8gVVJMIGFzIHRoaXMgY2FuIGVuZCB1cCB3aXRoIGFuIGluZmluaXRlIHJlZnJlc2hcbiAgICBpZiAodXJsID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHJvdXRlci5hc1BhdGgsIHJvdXRlci5sb2NhbGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBoYXJkIG5hdmlnYXRlIHRvIHRoZSBzYW1lIFVSTCBcIiArIHVybCArIFwiIFwiICsgbG9jYXRpb24uaHJlZik7XG4gICAgfVxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xufVxuY29uc3QgZ2V0Q2FuY2VsbGVkSGFuZGxlciA9IChwYXJhbSk9PntcbiAgICBsZXQgeyByb3V0ZSAsIHJvdXRlciAgfSA9IHBhcmFtO1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjYW5jZWwgPSByb3V0ZXIuY2xjID0gKCk9PntcbiAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9ICgpPT57XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIicgKyByb3V0ZSArICdcIicpO1xuICAgICAgICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5jZWwgPT09IHJvdXRlci5jbGMpIHtcbiAgICAgICAgICAgIHJvdXRlci5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaGFuZGxlQ2FuY2VsbGVkO1xufTtcbmNsYXNzIFJvdXRlciB7XG4gICAgcmVsb2FkKCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovIGJhY2soKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdvIGZvcndhcmQgaW4gaGlzdG9yeVxuICAgKi8gZm9yd2FyZCgpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHB1c2godXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSB3aGVuIHdlIHVwZGF0ZSBoaXN0b3J5IGJlZm9yZSByb3V0ZSBjaGFuZ2VcbiAgICAgICAgICAgIC8vIGlzIGNvbXBsZXRlLCBhcyB0aGUgcG9wc3RhdGUgZXZlbnQgc2hvdWxkIGhhbmRsZSB0aGlzIGNhcHR1cmUuXG4gICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBzY3JvbGwgcG9zaXRpb24gcmlnaHQgYmVmb3JlIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZTpcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcIl9fbmV4dF9zY3JvbGxfXCIgKyB0aGlzLl9rZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKFwicHVzaFN0YXRlXCIsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHJlcGxhY2UodXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKFwicmVwbGFjZVN0YXRlXCIsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBfYmZsKGFzLCByZXNvbHZlZEFzLCBsb2NhbGUsIHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsU3RhdGljID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbER5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3VyQXMgb2YgW1xuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXNcbiAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgIGlmIChjdXJBcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2ggPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkobmV3IFVSTChjdXJBcywgXCJodHRwOi8vblwiKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaExvY2FsZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXNOb1NsYXNoLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzTm9TbGFzaCAhPT0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwodGhpcy5hc1BhdGgsIFwiaHR0cDovL25cIikucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2JmbF9zLCBfdGhpc19fYmZsX3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc0JmbFN0YXRpYyA9IG1hdGNoZXNCZmxTdGF0aWMgfHwgISEoKF90aGlzX19iZmxfcyA9IHRoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zLmhhcyhhc05vU2xhc2gpKSB8fCAhISgoX3RoaXNfX2JmbF9zMSA9IHRoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zMS5oYXMoYXNOb1NsYXNoTG9jYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRBUyBvZiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzTm9TbGFzaExvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgXSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYW55IHN1Yi1wYXRoIG9mIGFzIG1hdGNoZXMgYSBkeW5hbWljIGZpbHRlciBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGhhcmQgbmF2aWdhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyQXNQYXJ0cyA9IG5vcm1hbGl6ZWRBUy5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgIW1hdGNoZXNCZmxEeW5hbWljICYmIGkgPCBjdXJBc1BhcnRzLmxlbmd0aCArIDE7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpc19fYmZsX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXJ0ID0gY3VyQXNQYXJ0cy5zbGljZSgwLCBpKS5qb2luKFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0ICYmICgoX3RoaXNfX2JmbF9kID0gdGhpcy5fYmZsX2QpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX2QuaGFzKGN1cnJlbnRQYXJ0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNsaWVudCByb3V0ZXIgZmlsdGVyIGlzIG1hdGNoZWQgdGhlbiB3ZSB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNCZmxTdGF0aWMgfHwgbWF0Y2hlc0JmbER5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhcywgbG9jYWxlIHx8IHRoaXMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBjaGFuZ2UobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zLCBmb3JjZWRTY3JvbGwpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWU7XG4gICAgICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKHVybCkpIHtcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAgICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgIGNvbnN0IGlzUXVlcnlVcGRhdGluZyA9IG9wdGlvbnMuX2ggPT09IDE7XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2JmbChhcywgdW5kZWZpbmVkLCBvcHRpb25zLmxvY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNob3VsZFJlc29sdmVIcmVmID0gaXNRdWVyeVVwZGF0aW5nIHx8IG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmIHx8ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkodXJsKS5wYXRobmFtZSA9PT0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShhcykucGF0aG5hbWU7XG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RhdGVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgICAgICAvLyBvciBhIG5hdmlnYXRpb24gaGFzIG9jY3VycmVkXG4gICAgICAgIGNvbnN0IHJlYWR5U3RhdGVDaGFuZ2UgPSB0aGlzLmlzUmVhZHkgIT09IHRydWU7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGlzU3NyID0gdGhpcy5pc1NzcjtcbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhIHJvdXRlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBiZWZvcmVcbiAgICAgICAgLy8gdGhlIHF1ZXJ5IHVwZGF0aW5nIGlzIHRyaWdnZXJlZCBpZ25vcmUgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLmNsYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZMb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/IHRoaXMuZGVmYXVsdExvY2FsZSA6IG9wdGlvbnMubG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXJzZWRBcy5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKSh1cmwpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkodXJsKSA6IHVybCwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpc19sb2NhbGVzO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgICAgICAgICBpZiAoISgoX3RoaXNfbG9jYWxlcyA9IHRoaXMubG9jYWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX2xvY2FsZXMuaW5jbHVkZXMobmV4dFN0YXRlLmxvY2FsZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShwYXJzZWRBcy5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gKDAsIF9kZXRlY3Rkb21haW5sb2NhbGUuZGV0ZWN0RG9tYWluTG9jYWxlKSh0aGlzLmRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbmF2aWdhdGluZyB0byBhIGRvbWFpbiBsb2NhbGUgZW5zdXJlIHdlIHJlZGlyZWN0IHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgZG9tYWluXG4gICAgICAgICAgICAgICAgaWYgKCFkaWROYXZpZ2F0ZSAmJiBkZXRlY3RlZERvbWFpbiAmJiB0aGlzLmlzTG9jYWxlRG9tYWluICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcyk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJodHRwXCIgKyAoZGV0ZWN0ZWREb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiICsgZGV0ZWN0ZWREb21haW4uZG9tYWluICsgKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoXCJcIiArIChuZXh0U3RhdGUubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgbmV4dFN0YXRlLmxvY2FsZSkgKyAoYXNOb0Jhc2VQYXRoID09PSBcIi9cIiA/IFwiXCIgOiBhc05vQmFzZVBhdGgpIHx8IFwiL1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICAgICAgaWYgKF91dGlscy5TVCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyayhcInJvdXRlQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2hhbGxvdyA9ZmFsc2UgLCBzY3JvbGwgPXRydWUgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCByb3V0ZVByb3BzID0ge1xuICAgICAgICAgICAgc2hhbGxvd1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSAmJiB0aGlzLmNsYykge1xuICAgICAgICAgICAgaWYgKCFpc1Nzcikge1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLCB0aGlzLl9pbkZsaWdodFJvdXRlLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xjKCk7XG4gICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBvcHRpb25zLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSk7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXM7XG4gICAgICAgIGNvbnN0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGUuYXNQYXRoID0gY2xlYW5lZEFzO1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiaGFzaENoYW5nZVN0YXJ0XCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQobmV4dFN0YXRlLCB0aGlzLmNvbXBvbmVudHNbbmV4dFN0YXRlLnJvdXRlXSwgbnVsbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiaGFzaENoYW5nZUNvbXBsZXRlXCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgLy8gaWYgd2UgZGV0ZWN0ZWQgdGhlIHBhdGggYXMgYXBwIHJvdXRlIGR1cmluZyBwcmVmZXRjaGluZ1xuICAgICAgICAvLyB0cmlnZ2VyIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICBpZiAoKF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUgPSB0aGlzLmNvbXBvbmVudHNbcGF0aG5hbWVdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfY29tcG9uZW50c19wYXRobmFtZS5fX2FwcFJvdXRlcikge1xuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAgICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgICAgIGxldCBwYWdlcywgcmV3cml0ZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgICAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgICAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBcInJlcGxhY2VTdGF0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhcztcbiAgICAgICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgICAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWUgPyAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGF0aG5hbWUpKSA6IHBhdGhuYW1lO1xuICAgICAgICBsZXQgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRBc1BhdGhuYW1lID0gYXMuc3RhcnRzV2l0aChcIi9cIikgJiYgKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGFzKS5wYXRobmFtZTtcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlUmV3cml0ZSA9ICEhKHBhcnNlZEFzUGF0aG5hbWUgJiYgcm91dGUgIT09IHBhcnNlZEFzUGF0aG5hbWUgJiYgKCEoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGUpIHx8ICEoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSkpKHBhcnNlZEFzUGF0aG5hbWUpKSk7XG4gICAgICAgIC8vIHdlIGRvbid0IGF0dGVtcHQgcmVzb2x2ZSBhc1BhdGggd2hlbiB3ZSBuZWVkIHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gbWlkZGxld2FyZSBhcyB0aGUgcmVzb2x2aW5nIHdpbGwgb2NjdXIgc2VydmVyLXNpZGVcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSAhb3B0aW9ucy5zaGFsbG93ICYmIGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgIHNob3VsZFJlc29sdmVIcmVmID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJlc29sdmVIcmVmICYmIHBhdGhuYW1lICE9PSBcIi9fZXJyb3JcIikge1xuICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKCgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoY2xlYW5lZEFzLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSksIHBhZ2VzLCByZXdyaXRlcywgcXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShhcykpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaHJlZjogXCInICsgdXJsICsgJ1wiIGFuZCBhczogXCInICsgYXMgKyAnXCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzJyArIFwiXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJlc29sdmVkQXMpLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBsZXQgcm91dGVNYXRjaCA9IGZhbHNlO1xuICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJvdXRlKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkocmVzb2x2ZWRBcyk7XG4gICAgICAgICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHJvdXRlKTtcbiAgICAgICAgICAgIHJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGUgPyAoMCwgX2ludGVycG9sYXRlYXMuaW50ZXJwb2xhdGVBcykocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSA6IHt9O1xuICAgICAgICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcigocGFyYW0pPT4hcXVlcnlbcGFyYW1dICYmICFyb3V0ZVJlZ2V4Lmdyb3Vwc1twYXJhbV0ub3B0aW9uYWwpO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDAgJiYgIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlwiICsgKHNob3VsZEludGVycG9sYXRlID8gXCJJbnRlcnBvbGF0aW5nIGhyZWZcIiA6IFwiTWlzbWF0Y2hpbmcgYGFzYCBhbmQgYGhyZWZgXCIpICsgXCIgZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgXCIgKyAoXCJ0aGUgcGFyYW1zOiBcIiArIG1pc3NpbmdQYXJhbXMuam9pbihcIiwgXCIpICsgXCIgaW4gdGhlIGBocmVmYCdzIGBxdWVyeWBcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBcIlRoZSBwcm92aWRlZCBgaHJlZmAgKFwiICsgdXJsICsgXCIpIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzIChcIiArIG1pc3NpbmdQYXJhbXMuam9pbihcIiwgXCIpICsgXCIpIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gXCIgOiBcIlRoZSBwcm92aWRlZCBgYXNgIHZhbHVlIChcIiArIGFzUGF0aG5hbWUgKyBcIikgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIGBocmVmYCB2YWx1ZSAoXCIgKyByb3V0ZSArIFwiKS4gXCIpICsgKFwiUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9cIiArIChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiaHJlZi1pbnRlcnBvbGF0aW9uLWZhaWxlZFwiIDogXCJpbmNvbXBhdGlibGUtaHJlZi1hc1wiKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogKDAsIF9vbWl0Lm9taXQpKHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZVN0YXJ0XCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0Vycm9yUm91dGUgPSB0aGlzLnBhdGhuYW1lID09PSBcIi80MDRcIiB8fCB0aGlzLnBhdGhuYW1lID09PSBcIi9fZXJyb3JcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzLCBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcywgX3JvdXRlSW5mb19wcm9wcztcbiAgICAgICAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogaXNNaWRkbGV3YXJlTWF0Y2gsXG4gICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbiAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhdGhpcy5pc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGlzTWlkZGxld2FyZVJld3JpdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2JmbChhcywgXCJyZXNvbHZlZEFzXCIgaW4gcm91dGVJbmZvID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwicm91dGVcIiBpbiByb3V0ZUluZm8gJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJvdXRlSW5mby5yb3V0ZSB8fCByb3V0ZTtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICghcm91dGVQcm9wcy5zaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGVJbmZvLnF1ZXJ5IHx8IHt9LCBxdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRQYXJzZWRQYXRobmFtZSA9ICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHBhcnNlZC5wYXRobmFtZSkgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXJzZWQucGF0aG5hbWUpIDogcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHBhdGhuYW1lICE9PSBjbGVhbmVkUGFyc2VkUGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocm91dGVNYXRjaCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcXVlcnlba2V5XSA9PT0gcm91dGVNYXRjaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXhlZEFzID0gIXJvdXRlUHJvcHMuc2hhbGxvdyAmJiByb3V0ZUluZm8ucmVzb2x2ZWRBcyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShuZXcgVVJMKGFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmV3cml0ZUFzID0gcHJlZml4ZWRBcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJld3JpdGVBcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVBcyA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJld3JpdGVBcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShyZXdyaXRlQXMsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSBsb2NhbGVSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1clJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKHJvdXRlUmVnZXgpKG5ldyBVUkwocmV3cml0ZUFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJSb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCBjdXJSb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSByb3V0ZUluZm8gYnJpbmdzIGEgcmVkaXJlY3Qgd2Ugc2ltcGx5IGFwcGx5IGl0LlxuICAgICAgICAgICAgaWYgKFwidHlwZVwiIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8udHlwZSA9PT0gXCJyZWRpcmVjdC1pbnRlcm5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIHJvdXRlSW5mby5uZXdVcmwsIHJvdXRlSW5mby5uZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByb3V0ZUluZm8uZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHJvdXRlSW5mby5Db21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHRzID0gW10uY29uY2F0KGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIoKSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpPT57XG4gICAgICAgICAgICAgICAgICAgICgwLCBfc2NyaXB0LmhhbmRsZUNsaWVudFNjcmlwdExvYWQpKHNjcmlwdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgICAgICAgIGlmICgocm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1ApICYmIHJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGVzdGluYXRpb24gZnJvbSByZWRpcmVjdCB3aXRob3V0IGFkZGluZyBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aChcIi9cIikgJiYgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RfQkFTRV9QQVRIICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkSHJlZiA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWRIcmVmLnBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsICwgYXM6IG5ld0FzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIGRlc3RpbmF0aW9uLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCBuZXdVcmwsIG5ld0FzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLmlzUHJldmlldyA9ICEhcm91dGVJbmZvLnByb3BzLl9fTl9QUkVWSUVXO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLm5vdEZvdW5kID09PSBTU0dfREFUQV9OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vdEZvdW5kUm91dGU7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFwiLzQwNFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSBcIi80MDRcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9IFwiL19lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTm90Rm91bmQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gLzQwNFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgJiYgKChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzID0gX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcy5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcy5zdGF0dXNDb2RlKSA9PT0gNTAwICYmICgoX3JvdXRlSW5mb19wcm9wcyA9IHJvdXRlSW5mby5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZUluZm9fcHJvcHMucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3JvdXRlSW5mb19yb3V0ZTtcbiAgICAgICAgICAgIC8vIHNoYWxsb3cgcm91dGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHNhbWUgcGFnZSBVUkwgY2hhbmdlcy5cbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRTaGFsbG93Um91dGUgPSBvcHRpb25zLnNoYWxsb3cgJiYgbmV4dFN0YXRlLnJvdXRlID09PSAoKF9yb3V0ZUluZm9fcm91dGUgPSByb3V0ZUluZm8ucm91dGUpICE9IG51bGwgPyBfcm91dGVJbmZvX3JvdXRlIDogcm91dGUpO1xuICAgICAgICAgICAgdmFyIF9vcHRpb25zX3Njcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IChfb3B0aW9uc19zY3JvbGwgPSBvcHRpb25zLnNjcm9sbCkgIT0gbnVsbCA/IF9vcHRpb25zX3Njcm9sbCA6ICFpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzVmFsaWRTaGFsbG93Um91dGU7XG4gICAgICAgICAgICBjb25zdCByZXNldFNjcm9sbCA9IHNob3VsZFNjcm9sbCA/IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgdXBjb21pbmdTY3JvbGxTdGF0ZSA9IGZvcmNlZFNjcm9sbCAhPSBudWxsID8gZm9yY2VkU2Nyb2xsIDogcmVzZXRTY3JvbGw7XG4gICAgICAgICAgICAvLyB0aGUgbmV3IHN0YXRlIHRoYXQgdGhlIHJvdXRlciBnb25uYSBzZXRcbiAgICAgICAgICAgIGNvbnN0IHVwY29taW5nUm91dGVyU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4ubmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzUGF0aDogY2xlYW5lZEFzLFxuICAgICAgICAgICAgICAgIGlzRmFsbGJhY2s6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgcGFnZSBiZWluZyByZW5kZXJlZCBpcyB0aGUgNDA0IHBhZ2UsIHdlIHNob3VsZCBvbmx5IHVwZGF0ZSB0aGVcbiAgICAgICAgICAgIC8vIHF1ZXJ5IHBhcmFtZXRlcnMuIFJvdXRlIGNoYW5nZXMgaGVyZSBtaWdodCBhZGQgdGhlIGJhc2VQYXRoIHdoZW4gaXRcbiAgICAgICAgICAgIC8vIHdhc24ndCBvcmlnaW5hbGx5IHByZXNlbnQuIFRoaXMgaXMgYWxzbyB3aHkgdGhpcyBibG9jayBpcyBiZWZvcmUgdGhlXG4gICAgICAgICAgICAvLyBiZWxvdyBgY2hhbmdlU3RhdGVgIGNhbGwgd2hpY2ggdXBkYXRlcyB0aGUgYnJvd3NlcidzIGhpc3RvcnkgKGNoYW5naW5nXG4gICAgICAgICAgICAvLyB0aGUgVVJMKS5cbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgaXNFcnJvclJvdXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxLCBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEsIF9yb3V0ZUluZm9fcHJvcHMxO1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGU6IHRoaXMucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhdGhpcy5pc0ZhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKFwidHlwZVwiIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1pZGRsZXdhcmUgZWZmZWN0IG9uIFwiICsgdGhpcy5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhdGhuYW1lID09PSBcIi9fZXJyb3JcIiAmJiAoKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMSA9IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxLnBhZ2VQcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMS5zdGF0dXNDb2RlKSA9PT0gNTAwICYmICgoX3JvdXRlSW5mb19wcm9wczEgPSByb3V0ZUluZm8ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfcm91dGVJbmZvX3Byb3BzMS5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgZXJyLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJiZWZvcmVIaXN0b3J5Q2hhbmdlXCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGZvciBxdWVyeSB1cGRhdGVzIHdlIGNhbiBza2lwIGl0IGlmIHRoZSBzdGF0ZSBpcyB1bmNoYW5nZWQgYW5kIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHNjcm9sbFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy8zNzEzOVxuICAgICAgICAgICAgY29uc3QgY2FuU2tpcFVwZGF0aW5nID0gaXNRdWVyeVVwZGF0aW5nICYmICF1cGNvbWluZ1Njcm9sbFN0YXRlICYmICFyZWFkeVN0YXRlQ2hhbmdlICYmICFsb2NhbGVDaGFuZ2UgJiYgKDAsIF9jb21wYXJlc3RhdGVzLmNvbXBhcmVSb3V0ZXJTdGF0ZXMpKHVwY29taW5nUm91dGVyU3RhdGUsIHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgaWYgKCFjYW5Ta2lwVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSByb3V0ZUluZm8uZXJyb3IgPSByb3V0ZUluZm8uZXJyb3IgfHwgZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIHJvdXRlSW5mby5lcnJvciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyByb3V0ZUluZm8uZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VDb21wbGV0ZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgaGFzaCBtYXJrICMgaXMgdGhlIG9wdGlvbmFsIGxhc3QgcGFydCBvZiBhIFVSTFxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2hSZWdleCA9IC8jLiskLztcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsICYmIGhhc2hSZWdleC50ZXN0KGFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2FybmluZzogd2luZG93Lmhpc3RvcnkuXCIgKyBtZXRob2QgKyBcIiBpcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kICE9PSBcInB1c2hTdGF0ZVwiIHx8ICgwLCBfdXRpbHMuZ2V0VVJMKSgpICE9PSBhcykge1xuICAgICAgICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvdztcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuX2tleSA9IG1ldGhvZCAhPT0gXCJwdXNoU3RhdGVcIiA/IHRoaXMuX2tleSA6IGNyZWF0ZUtleSgpXG4gICAgICAgICAgICB9LCAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAgICAgXCJcIiwgYXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKGVyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgX3JvdXRlbG9hZGVyLmlzQXNzZXRFcnJvcikoZXJyKSB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgICAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgICAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgICAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICAgICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBwcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHsgcGFnZTogQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFwiL19lcnJvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6IFwiLCBnaXBFcnIpO1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNlcnJvci5kZWZhdWx0KShyb3V0ZUluZm9FcnIpID8gcm91dGVJbmZvRXJyIDogbmV3IEVycm9yKHJvdXRlSW5mb0VyciArIFwiXCIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRSb3V0ZUluZm8ocGFyYW0pIHtcbiAgICAgICAgbGV0IHsgcm91dGU6IHJlcXVlc3RlZFJvdXRlICwgcGF0aG5hbWUgLCBxdWVyeSAsIGFzICwgcmVzb2x2ZWRBcyAsIHJvdXRlUHJvcHMgLCBsb2NhbGUgLCBoYXNNaWRkbGV3YXJlICwgaXNQcmV2aWV3ICwgdW5zdGFibGVfc2tpcENsaWVudENhY2hlICwgaXNRdWVyeVVwZGF0aW5nICwgaXNNaWRkbGV3YXJlUmV3cml0ZSAsIGlzTm90Rm91bmQgIH0gPSBwYXJhbTtcbiAgICAgICAgLyoqXG4gICAgICogVGhpcyBgcm91dGVgIGJpbmRpbmcgY2FuIGNoYW5nZSBpZiB0aGVyZSdzIGEgcmV3cml0ZVxuICAgICAqIHNvIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIHJlcXVlc3RlZCByb3V0ZVxuICAgICAqIHNvIHdlIGNhbiBzdG9yZSB0aGUgY2FjaGUgZm9yIGl0IGFuZCBhdm9pZCByZS1yZXF1ZXN0aW5nIGV2ZXJ5IHRpbWVcbiAgICAgKiBmb3Igc2hhbGxvdyByb3V0aW5nIHB1cnBvc2VzLlxuICAgICAqLyBsZXQgcm91dGUgPSByZXF1ZXN0ZWRSb3V0ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfZGF0YV9lZmZlY3QsIF9kYXRhX2VmZmVjdDEsIF9kYXRhX2VmZmVjdDIsIF9kYXRhX3Jlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBleGlzdGluZ0luZm8gPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdO1xuICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0luZm8gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2FjaGVkUm91dGVJbmZvID0gZXhpc3RpbmdJbmZvICYmICEoXCJpbml0aWFsXCIgaW4gZXhpc3RpbmdJbmZvKSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiID8gZXhpc3RpbmdJbmZvIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNCYWNrZ3JvdW5kID0gaXNRdWVyeVVwZGF0aW5nO1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hOZXh0RGF0YVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhSHJlZjogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IGlzTm90Rm91bmQgPyBcIi80MDRcIiA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRoaXMuaXNTc3IsXG4gICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IGlzQmFja2dyb3VuZCA/IHRoaXMuc2JjIDogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbiAgICAgICAgICAgICAgICBpc0JhY2tncm91bmRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGlzUXVlcnlVcGRhdGluZyAmJiAhaXNNaWRkbGV3YXJlUmV3cml0ZSA/IG51bGwgOiBhd2FpdCB3aXRoTWlkZGxld2FyZUVmZmVjdHMoe1xuICAgICAgICAgICAgICAgIGZldGNoRGF0YTogKCk9PmZldGNoTmV4dERhdGEoZmV0Y2hOZXh0RGF0YVBhcmFtcyksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gXCIvNDA0XCIgOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXJkIGVycm9yIGR1cmluZyBxdWVyeSB1cGRhdGluZ1xuICAgICAgICAgICAgICAgIC8vIGFzIGl0J3MgdW4tbmVjZXNzYXJ5IGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgZmF0YWxcbiAgICAgICAgICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBmYWxsYmFjayByb3V0ZSBhbmQgdGhlIHByb3BzIGNhbid0XG4gICAgICAgICAgICAgICAgLy8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3aGVuIHJlbmRlcmluZyBlcnJvciByb3V0ZXMgd2UgZG9uJ3QgYXBwbHkgbWlkZGxld2FyZVxuICAgICAgICAgICAgLy8gZWZmZWN0c1xuICAgICAgICAgICAgaWYgKGRhdGEgJiYgKHBhdGhuYW1lID09PSBcIi9fZXJyb3JcIiB8fCBwYXRobmFtZSA9PT0gXCIvNDA0XCIpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lZmZlY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uOiBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmpzb24gPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdC50eXBlKSA9PT0gXCJyZWRpcmVjdC1pbnRlcm5hbFwiIHx8IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfZWZmZWN0MSA9IGRhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfZWZmZWN0MS50eXBlKSA9PT0gXCJyZWRpcmVjdC1leHRlcm5hbFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZWZmZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfZWZmZWN0MiA9IGRhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfZWZmZWN0Mi50eXBlKSA9PT0gXCJyZXdyaXRlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZFJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgcXVlcnkgdXBkYXRpbmcgdGhlIHBhZ2UgbXVzdCBtYXRjaCBhbHRob3VnaCBkdXJpbmdcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtdHJhbnNpdGlvbiBhIHJlZGlyZWN0IHRoYXQgZG9lc24ndCBtYXRjaCBhIHBhZ2VcbiAgICAgICAgICAgICAgICAvLyBjYW4gYmUgcmV0dXJuZWQgYW5kIHRoaXMgc2hvdWxkIHRyaWdnZXIgYSBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAvLyB3aGljaCBpcyB2YWxpZCBmb3IgaW5jcmVtZW50YWwgbWlncmF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgfHwgcGFnZXMuaW5jbHVkZXMocmVzb2x2ZWRSb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgPSByZXNvbHZlZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGEuZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBhZ2FpbiB0aGUgY2FjaGUgd2l0aCB0aGUgbmV3IGRlc3RpbmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0luZm8gPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSAmJiAhaGFzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1hdGNoIHdpdGggdGhlIGN1cnJlbnQgcm91dGUgZHVlIHRvIHJld3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gY29weSB0aGUgZXhpc3RpbmcgaW5mb3JtYXRpb24gdG8gdGhlIHJld3JpdHRlbiBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuLCB3ZSByZXR1cm4gdGhlIGluZm9ybWF0aW9uIGFsb25nIHdpdGggdGhlIG1hdGNoZWQgcm91dGUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgX2lzYXBpcm91dGUuaXNBUElSb3V0ZSkocm91dGUpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IGNhY2hlZFJvdXRlSW5mbyB8fCBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKChyZXMpPT4oe1xuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSAgfSA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUocm91dGVJbmZvLkNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJyArIHBhdGhuYW1lICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2FzQmFpbGVkUHJlZmV0Y2ggPSBkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfcmVzcG9uc2UgPSBkYXRhLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1pZGRsZXdhcmUtc2tpcFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEZldGNoRGF0YSA9IHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQO1xuICAgICAgICAgICAgLy8gRm9yIG5vbi1TU0cgcHJlZmV0Y2hlcyB0aGF0IGJhaWxlZCBiZWZvcmUgc2VuZGluZyBkYXRhXG4gICAgICAgICAgICAvLyB3ZSBjbGVhciB0aGUgY2FjaGUgdG8gZmV0Y2ggZnVsbCByZXNwb25zZVxuICAgICAgICAgICAgaWYgKHdhc0JhaWxlZFByZWZldGNoICYmIChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tkYXRhLmRhdGFIcmVmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgLCBjYWNoZUtleSAgfSA9IGF3YWl0IHRoaXMuX2dldERhdGEoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRmV0Y2hEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5qc29uKSAmJiAhd2FzQmFpbGVkUHJlZmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGRhdGEuanNvblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhSHJlZiA9IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmKSA/IGRhdGEuZGF0YUhyZWYgOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoZWQgPSBhd2FpdCBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRoaXMuaXNTc3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB3YXNCYWlsZWRQcmVmZXRjaCA/IHt9IDogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBmZXRjaGVkLmNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGZldGNoZWQuanNvbiB8fCB7fVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKHJvdXRlSW5mby5Db21wb25lbnQsIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlczogdGhpcy5sb2NhbGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gT25seSBidXN0IHRoZSBkYXRhIGNhY2hlIGZvciBTU1Agcm91dGVzIGFsdGhvdWdoXG4gICAgICAgICAgICAvLyBtaWRkbGV3YXJlIGNhbiBza2lwIGNhY2hlIHBlciByZXF1ZXN0IHdpdGhcbiAgICAgICAgICAgIC8vIHgtbWlkZGxld2FyZS1jYWNoZTogbm8tY2FjaGUgYXMgd2VsbFxuICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5fX05fU1NQICYmIGZldGNoTmV4dERhdGFQYXJhbXMuZGF0YUhyZWYgJiYgY2FjaGVLZXkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZGNbY2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2Uga2ljayBvZmYgYSBIRUFEIHJlcXVlc3QgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICAgICAgIC8vIHdoZW4gYSBub24tcHJlZmV0Y2ggcmVxdWVzdCBpcyBtYWRlIHRvIHNpZ25hbCByZXZhbGlkYXRpb25cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ByZXZpZXcgJiYgcm91dGVJbmZvLl9fTl9TU0cgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwiZGV2ZWxvcG1lbnRcIiAmJiAhaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgZmV0Y2hOZXh0RGF0YShPYmplY3QuYXNzaWduKHt9LCBmZXRjaE5leHREYXRhUGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgIGlzQmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zYmNcbiAgICAgICAgICAgICAgICB9KSkuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BzLnBhZ2VQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLnBhZ2VQcm9wcyk7XG4gICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgIHJvdXRlSW5mby5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICAgICAgcm91dGVJbmZvLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICByb3V0ZUluZm8ucmVzb2x2ZWRBcyA9IHJlc29sdmVkQXM7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzZXJyb3IuZ2V0UHJvcGVyRXJyb3IpKGVyciksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChzdGF0ZSwgZGF0YSwgcmVzZXRTY3JvbGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIoZGF0YSwgdGhpcy5jb21wb25lbnRzW1wiL19hcHBcIl0uQ29tcG9uZW50LCByZXNldFNjcm9sbCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi8gYmVmb3JlUG9wU3RhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5fYnBzID0gY2I7XG4gICAgfVxuICAgIG9ubHlBSGFzaENoYW5nZShhcykge1xuICAgICAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoXCIjXCIpO1xuICAgICAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoO1xuICAgIH1cbiAgICBzY3JvbGxUb0hhc2goYXMpIHtcbiAgICAgICAgY29uc3QgWywgaGFzaCA9IFwiXCJdID0gYXMuc3BsaXQoXCIjXCIpO1xuICAgICAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWUgb3IgYCN0b3BgXG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBpZiAoaGFzaCA9PT0gXCJcIiB8fCBoYXNoID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgICAoMCwgX2hhbmRsZXNtb290aHNjcm9sbC5oYW5kbGVTbW9vdGhTY3JvbGwpKCgpPT53aW5kb3cuc2Nyb2xsVG8oMCwgMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlY29kZSBoYXNoIHRvIG1ha2Ugbm9uLWxhdGluIGFuY2hvciB3b3Jrcy5cbiAgICAgICAgY29uc3QgcmF3SGFzaCA9IGRlY29kZVVSSUNvbXBvbmVudChoYXNoKTtcbiAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJhd0hhc2gpO1xuICAgICAgICBpZiAoaWRFbCkge1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+aWRFbC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKHJhd0hhc2gpWzBdO1xuICAgICAgICBpZiAobmFtZUVsKSB7XG4gICAgICAgICAgICAoMCwgX2hhbmRsZXNtb290aHNjcm9sbC5oYW5kbGVTbW9vdGhTY3JvbGwpKCgpPT5uYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXJsSXNOZXcoYXNQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqLyBhc3luYyBwcmVmZXRjaCh1cmwsIGFzUGF0aCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoYXNQYXRoID09PSB2b2lkIDApIGFzUGF0aCA9IHVybDtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoMCwgX2lzYm90LmlzQm90KSh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIC8vIE5vIHByZWZldGNoZXMgZm9yIGJvdHMgdGhhdCByZW5kZXIgdGhlIGxpbmsgc2luY2UgdGhleSBhcmUgdHlwaWNhbGx5IG5hdmlnYXRpbmdcbiAgICAgICAgICAgIC8vIGxpbmtzIHZpYSB0aGUgZXF1aXZhbGVudCBvZiBhIGhhcmQgbmF2aWdhdGlvbiBhbmQgaGVuY2UgbmV2ZXIgdXRpbGl6ZSB0aGVzZVxuICAgICAgICAgICAgLy8gcHJlZmV0Y2hlcy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgIGNvbnN0IHVybFBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGFzUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgICAgICBhc1BhdGggPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXNQYXRoO1xuICAgICAgICBjb25zdCBsb2NhbGUgPSB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmxvY2FsZSB8fCB1bmRlZmluZWQgOiB0aGlzLmxvY2FsZTtcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhc1BhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGxldCByZXdyaXRlcztcbiAgICAgICAgICAgICh7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9ID0gYXdhaXQgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhc1BhdGgsIHRoaXMubG9jYWxlKSwgdHJ1ZSksIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkLnF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlc1Jlc3VsdC5hc1BhdGgpLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXJzZWQucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGFyc2VkLnBhdGhuYW1lKSkoKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShhc1BhdGgpLnBhdGhuYW1lKSB8fCB7fSk7XG4gICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIID09PSBcInN0cmljdFwiID8gbnVsbCA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBvcmlnaW5hbFBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhdGhpcy5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFzUGF0aDogYXNQYXRoLFxuICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZXJlIHdhcyBhIHJld3JpdGUgd2UgYXBwbHkgdGhlIGVmZmVjdHMgb2YgdGhlIHJld3JpdGUgb24gdGhlXG4gICAgICogY3VycmVudCBwYXJhbWV0ZXJzIGZvciB0aGUgcHJlZmV0Y2guXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09IFwicmV3cml0ZVwiKSB7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBwYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIC4uLmRhdGEuZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgYSByZWRpcmVjdCB0byBhbiBleHRlcm5hbCBkZXN0aW5hdGlvbiB0aGVuIHdlIGRvbid0IGhhdmVcbiAgICAgKiB0byBwcmVmZXRjaCBjb250ZW50IGFzIGl0IHdpbGwgYmUgdW51c2VkLlxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSBcInJlZGlyZWN0LWV4dGVybmFsXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLl9iZmwoYXNQYXRoLCByZXNvbHZlZEFzLCBvcHRpb25zLmxvY2FsZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1t1cmxQYXRobmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgX19hcHBSb3V0ZXI6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyhyb3V0ZSkudGhlbigoaXNTc2cpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU3NnID8gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5qc29uKSA/IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYgOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhdGhpcy5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgfHwgb3B0aW9ucy5wcmlvcml0eSAmJiAhIXByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKCk9PmZhbHNlKS5jYXRjaCgoKT0+ZmFsc2UpIDogZmFsc2U7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gXCJsb2FkUGFnZVwiIDogXCJwcmVmZXRjaFwiXShyb3V0ZSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXREYXRhKGZuKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZFwiKTtcbiAgICAgICAgICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGbGlnaHREYXRhKGRhdGFIcmVmKSB7XG4gICAgICAgIC8vIERvIG5vdCBjYWNoZSBSU0MgZmxpZ2h0IHJlc3BvbnNlIHNpbmNlIGl0J3Mgbm90IGEgc3RhdGljIHJlc291cmNlXG4gICAgICAgIHJldHVybiBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRydWUsXG4gICAgICAgICAgICBwYXJzZUpTT046IGZhbHNlLFxuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2VcbiAgICAgICAgfSkudGhlbigocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyB0ZXh0ICB9ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCAgfSA9IHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmxvYWRHZXRJbml0aWFsUHJvcHMpKEFwcCwge1xuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHJvdXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb3V0ZTtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgZ2V0IHF1ZXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWVyeTtcbiAgICB9XG4gICAgZ2V0IGFzUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuYXNQYXRoO1xuICAgIH1cbiAgICBnZXQgbG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5sb2NhbGU7XG4gICAgfVxuICAgIGdldCBpc0ZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ZhbGxiYWNrO1xuICAgIH1cbiAgICBnZXQgaXNQcmV2aWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc1ByZXZpZXc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGhuYW1lLCBxdWVyeSwgYXMsIHsgaW5pdGlhbFByb3BzICwgcGFnZUxvYWRlciAsIEFwcCAsIHdyYXBBcHAgLCBDb21wb25lbnQgLCBlcnIgLCBzdWJzY3JpcHRpb24gLCBpc0ZhbGxiYWNrICwgbG9jYWxlICwgbG9jYWxlcyAsIGRlZmF1bHRMb2NhbGUgLCBkb21haW5Mb2NhbGVzICwgaXNQcmV2aWV3ICB9KXtcbiAgICAgICAgLy8gU2VydmVyIERhdGEgQ2FjaGUgKGZ1bGwgZGF0YSByZXF1ZXN0cylcbiAgICAgICAgdGhpcy5zZGMgPSB7fTtcbiAgICAgICAgLy8gU2VydmVyIEJhY2tncm91bmQgQ2FjaGUgKEhFQUQgcmVxdWVzdHMpXG4gICAgICAgIHRoaXMuc2JjID0ge307XG4gICAgICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9rZXkgPSBjcmVhdGVLZXkoKTtcbiAgICAgICAgdGhpcy5vblBvcFN0YXRlID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCB7IGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgICAgICAgICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgICAgICAgICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgICAgICAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAgICAgICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFwicmVwbGFjZVN0YXRlXCIsICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSksICgwLCBfdXRpbHMuZ2V0VVJMKSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAgICAgICBpZiAoc3RhdGUuX19OQSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBwb3BzdGF0ZWV2ZW50IHdoZW4gcmVvcGVuaW5nIHRoZSBicm93c2VyLlxuICAgICAgICAgICAgaWYgKGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICYmIHRoaXMubG9jYWxlID09PSBzdGF0ZS5vcHRpb25zLmxvY2FsZSAmJiBzdGF0ZS5hcyA9PT0gdGhpcy5hc1BhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2VkU2Nyb2xsO1xuICAgICAgICAgICAgY29uc3QgeyB1cmwgLCBhcyAsIG9wdGlvbnMgLCBrZXkgIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9rZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcIl9fbmV4dF9zY3JvbGxfXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IEpTT04ucGFyc2Uodik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5hc1BhdGgpICYmIHBhdGhuYW1lID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSh0aGlzLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoXCJyZXBsYWNlU3RhdGVcIiwgdXJsLCBhcywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgdmFsdWUgbm90IGV4cG9zZWQgb24gdHlwZXNcbiAgICAgICAgICAgICAgICBfaDogMFxuICAgICAgICAgICAgfSksIGZvcmNlZFNjcm9sbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgICAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgICAgIGlmIChwYXRobmFtZSAhPT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICAgICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXSA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogQXBwLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xuICAgICAgICAgICAgY29uc3QgeyBCbG9vbUZpbHRlciAgfSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvYmxvb20tZmlsdGVyXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGljRmlsdGVyRGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NfRklMVEVSO1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY0ZpbHRlckRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUjtcbiAgICAgICAgICAgIGlmIChzdGF0aWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBzdGF0aWNGaWx0ZXJEYXRhLmhhc2hlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9zID0gbmV3IEJsb29tRmlsdGVyKHN0YXRpY0ZpbHRlckRhdGEuc2l6ZSwgc3RhdGljRmlsdGVyRGF0YS5oYXNoZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9zLmltcG9ydChzdGF0aWNGaWx0ZXJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeW5hbWljRmlsdGVyRGF0YSA9PSBudWxsID8gdm9pZCAwIDogZHluYW1pY0ZpbHRlckRhdGEuaGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX2QgPSBuZXcgQmxvb21GaWx0ZXIoZHluYW1pY0ZpbHRlckRhdGEuc2l6ZSwgZHluYW1pY0ZpbHRlckRhdGEuaGFzaGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZC5pbXBvcnQoZHluYW1pY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50cztcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlcjtcbiAgICAgICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAgICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICAgICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPSAoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGF0aG5hbWUpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSAhIShzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3AgfHwgIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJiAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISEoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKGRvbWFpbkxvY2FsZXMsIHNlbGYubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhc1BhdGg6IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhcyxcbiAgICAgICAgICAgIGlzUHJldmlldzogISFpc1ByZXZpZXcsXG4gICAgICAgICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0ZhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoIWFzLnN0YXJ0c1dpdGgoXCIvL1wiKSkge1xuICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc1BhdGggPSAoMCwgX3V0aWxzLmdldFVSTCkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoXG4gICAgICAgICAgICAgICAgfSkudGhlbigobWF0Y2hlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSBhcyAhPT0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXCJyZXBsYWNlU3RhdGVcIiwgbWF0Y2hlcyA/IGFzUGF0aCA6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSksIGFzUGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpO1xuICAgICAgICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbigoKT0+e1xuICAgIFJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQuZGVmYXVsdCkoKTtcbn0pKCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJtYXRjaGVzTWlkZGxld2FyZSIsImNyZWF0ZUtleSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIlJvdXRlciIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlbW92ZXRyYWlsaW5nc2xhc2giLCJfcm91dGVsb2FkZXIiLCJfc2NyaXB0IiwiX2lzZXJyb3IiLCJfIiwiX2Rlbm9ybWFsaXplcGFnZXBhdGgiLCJfbm9ybWFsaXplbG9jYWxlcGF0aCIsIl9taXR0IiwiX3V0aWxzIiwiX2lzZHluYW1pYyIsIl9wYXJzZXJlbGF0aXZldXJsIiwiX3Jlc29sdmVyZXdyaXRlcyIsIl9yb3V0ZW1hdGNoZXIiLCJfcm91dGVyZWdleCIsIl9mb3JtYXR1cmwiLCJfZGV0ZWN0ZG9tYWlubG9jYWxlIiwiX3BhcnNlcGF0aCIsIl9hZGRsb2NhbGUiLCJfcmVtb3ZlbG9jYWxlIiwiX3JlbW92ZWJhc2VwYXRoIiwiX2FkZGJhc2VwYXRoIiwiX2hhc2Jhc2VwYXRoIiwiX2lzYXBpcm91dGUiLCJfZ2V0bmV4dHBhdGhuYW1laW5mbyIsIl9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvIiwiX2NvbXBhcmVzdGF0ZXMiLCJfaXNsb2NhbHVybCIsIl9pc2JvdCIsIl9vbWl0IiwiX3Jlc29sdmVocmVmIiwiX2ludGVycG9sYXRlYXMiLCJfaGFuZGxlc21vb3Roc2Nyb2xsIiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsImFzc2lnbiIsIkVycm9yIiwiY2FuY2VsbGVkIiwib3B0aW9ucyIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJtYXRjaGVycyIsInBhcnNlUGF0aCIsImFzUGF0aCIsImFzUGF0aG5hbWUiLCJwYXRobmFtZSIsImNsZWFuZWRBcyIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwibG9jYWxlIiwic29tZSIsIm0iLCJSZWdFeHAiLCJyZWdleHAiLCJ0ZXN0Iiwic3RyaXBPcmlnaW4iLCJ1cmwiLCJvcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVIcmVmIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsImhyZWZXYXNBYnNvbHV0ZSIsImFzV2FzQWJzb2x1dGUiLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJpbmNsdWRlcyIsInBhZ2UiLCJpc0R5bmFtaWNSb3V0ZSIsImdldFJvdXRlUmVnZXgiLCJyZSIsImdldE1pZGRsZXdhcmVEYXRhIiwic291cmNlIiwicmVzcG9uc2UiLCJuZXh0Q29uZmlnIiwiYmFzZVBhdGgiLCJpMThuIiwibG9jYWxlcyIsInRyYWlsaW5nU2xhc2giLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInJld3JpdGVIZWFkZXIiLCJoZWFkZXJzIiwicmV3cml0ZVRhcmdldCIsIm1hdGNoZWRQYXRoIiwiX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFIiwicGFyc2VkUmV3cml0ZVRhcmdldCIsInBhcnNlUmVsYXRpdmVVcmwiLCJwYXRobmFtZUluZm8iLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGFyc2VEYXRhIiwiZnNQYXRobmFtZSIsImdldFBhZ2VMaXN0IiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsInRoZW4iLCJwYXJhbSIsInJld3JpdGVzIiwiX19yZXdyaXRlcyIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJwYXJzZWRTb3VyY2UiLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwicmVzdWx0IiwicXVlcnkiLCJwYXRoIiwibWF0Y2hlZFBhZ2UiLCJwYXJzZWRBcyIsInJlc29sdmVkUGF0aG5hbWUiLCJtYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwidHlwZSIsInNyYyIsImZvcm1hdE5leHRQYXRobmFtZUluZm8iLCJkZWZhdWx0TG9jYWxlIiwiYnVpbGRJZCIsImRlc3RpbmF0aW9uIiwiaGFzaCIsInJlZGlyZWN0VGFyZ2V0IiwibmV3QXMiLCJuZXdVcmwiLCJ3aXRoTWlkZGxld2FyZUVmZmVjdHMiLCJmZXRjaERhdGEiLCJkYXRhIiwiZGF0YUhyZWYiLCJlZmZlY3QiLCJqc29uIiwidGV4dCIsImNhY2hlS2V5IiwibWFudWFsU2Nyb2xsUmVzdG9yYXRpb24iLCJfX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OIiwid2luZG93IiwiaGlzdG9yeSIsInYiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwibiIsIlNTR19EQVRBX05PVF9GT1VORCIsIlN5bWJvbCIsImZldGNoUmV0cnkiLCJhdHRlbXB0cyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJtZXRob2QiLCJvayIsInN0YXR1cyIsInRyeVRvUGFyc2VBc0pTT04iLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImZldGNoTmV4dERhdGEiLCJpbmZsaWdodENhY2hlIiwiaXNQcmVmZXRjaCIsImhhc01pZGRsZXdhcmUiLCJpc1NlcnZlclJlbmRlciIsInBhcnNlSlNPTiIsInBlcnNpc3RDYWNoZSIsImlzQmFja2dyb3VuZCIsInVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSIsIlVSTCIsImxvY2F0aW9uIiwiaHJlZiIsIl9wYXJhbXNfbWV0aG9kIiwiZ2V0RGF0YSIsInBhcmFtcyIsInB1cnBvc2UiLCJfdHJ5VG9QYXJzZUFzSlNPTiIsIm5vdEZvdW5kIiwibWFya0Fzc2V0RXJyb3IiLCJlcnIiLCJtZXNzYWdlIiwidW5kZWZpbmVkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJoYW5kbGVIYXJkTmF2aWdhdGlvbiIsImdldENhbmNlbGxlZEhhbmRsZXIiLCJyb3V0ZSIsImNhbmNlbCIsImNsYyIsImhhbmRsZUNhbmNlbGxlZCIsImluaXRpYWxQcm9wcyIsIkFwcCIsIndyYXBBcHAiLCJDb21wb25lbnQiLCJzdWJzY3JpcHRpb24iLCJpc0ZhbGxiYWNrIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsInNkYyIsInNiYyIsImlzRmlyc3RQb3BTdGF0ZUV2ZW50IiwiX2tleSIsIm9uUG9wU3RhdGUiLCJlIiwic3RhdGUiLCJjaGFuZ2VTdGF0ZSIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiZ2V0VVJMIiwiX19OQSIsInJlbG9hZCIsIl9fTiIsImZvcmNlZFNjcm9sbCIsImtleSIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiX2giLCJjb21wb25lbnRzIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJzdHlsZVNoZWV0cyIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiQmxvb21GaWx0ZXIiLCJzdGF0aWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIiLCJkeW5hbWljRmlsdGVyRGF0YSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIiwiaGFzaGVzIiwiX2JmbF9zIiwic2l6ZSIsIl9iZmxfZCIsImV2ZW50cyIsImF1dG9FeHBvcnREeW5hbWljIiwiX19ORVhUX0RBVEFfXyIsImF1dG9FeHBvcnQiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwic3ViIiwiX3dyYXBBcHAiLCJpc0xvY2FsZURvbWFpbiIsImlzUmVhZHkiLCJnc3NwIiwiZ2lwIiwiYXBwR2lwIiwiZ3NwIiwic2VhcmNoIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImRldGVjdERvbWFpbkxvY2FsZSIsImhvc3RuYW1lIiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJfc2hvdWxkUmVzb2x2ZUhyZWYiLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJiYWNrIiwiZm9yd2FyZCIsInNraXBOYXZpZ2F0ZSIsIm1hdGNoZXNCZmxTdGF0aWMiLCJtYXRjaGVzQmZsRHluYW1pYyIsImN1ckFzIiwiYXNOb1NsYXNoIiwiYXNOb1NsYXNoTG9jYWxlIiwiX3RoaXNfX2JmbF9zIiwiaGFzIiwiX3RoaXNfX2JmbF9zMSIsIm5vcm1hbGl6ZWRBUyIsImN1ckFzUGFydHMiLCJzcGxpdCIsImkiLCJjdXJyZW50UGFydCIsImpvaW4iLCJfdGhpc19fYmZsX2QiLCJpc0xvY2FsVVJMIiwiaXNRdWVyeVVwZGF0aW5nIiwiX2JmbCIsInNob3VsZFJlc29sdmVIcmVmIiwibmV4dFN0YXRlIiwicmVhZHlTdGF0ZUNoYW5nZSIsInByZXZMb2NhbGUiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkaWROYXZpZ2F0ZSIsIl90aGlzX2xvY2FsZXMiLCJkZXRlY3RlZERvbWFpbiIsImRvbWFpbiIsImFzTm9CYXNlUGF0aCIsImh0dHAiLCJTVCIsInBlcmZvcm1hbmNlIiwibWFyayIsInNjcm9sbCIsInJvdXRlUHJvcHMiLCJfaW5GbGlnaHRSb3V0ZSIsImVtaXQiLCJyZW1vdmVMb2NhbGUiLCJsb2NhbGVDaGFuZ2UiLCJvbmx5QUhhc2hDaGFuZ2UiLCJzY3JvbGxUb0hhc2giLCJzZXQiLCJwYXJzZWQiLCJfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lIiwiX19hcHBSb3V0ZXIiLCJ1cmxJc05ldyIsInBhcnNlZEFzUGF0aG5hbWUiLCJpc01pZGRsZXdhcmVSZXdyaXRlIiwiaXNNaWRkbGV3YXJlTWF0Y2giLCJyZXdyaXRlc1Jlc3VsdCIsInAiLCJleHRlcm5hbERlc3QiLCJyb3V0ZU1hdGNoIiwicm91dGVSZWdleCIsInNob3VsZEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGVkQXMiLCJpbnRlcnBvbGF0ZUFzIiwibWlzc2luZ1BhcmFtcyIsImtleXMiLCJncm91cHMiLCJmaWx0ZXIiLCJvcHRpb25hbCIsImNvbnNvbGUiLCJ3YXJuIiwib21pdCIsImlzRXJyb3JSb3V0ZSIsImdldFJvdXRlSW5mbyIsInJvdXRlSW5mbyIsImNsZWFuZWRQYXJzZWRQYXRobmFtZSIsImZvckVhY2giLCJwcmVmaXhlZEFzIiwicmV3cml0ZUFzIiwibG9jYWxlUmVzdWx0IiwiY3VyUm91dGVNYXRjaCIsImNvbXBvbmVudCIsInVuc3RhYmxlX3NjcmlwdExvYWRlciIsInNjcmlwdHMiLCJjb25jYXQiLCJzY3JpcHQiLCJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwicGFnZVByb3BzIiwiX19OX1JFRElSRUNUIiwiX19OX1JFRElSRUNUX0JBU0VfUEFUSCIsInBhcnNlZEhyZWYiLCJfX05fUFJFVklFVyIsImZldGNoQ29tcG9uZW50Iiwibm90Rm91bmRSb3V0ZSIsImlzTm90Rm91bmQiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMiLCJzdGF0dXNDb2RlIiwiX3JvdXRlSW5mb19wcm9wcyIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfcm91dGVJbmZvX3JvdXRlIiwic2hvdWxkU2Nyb2xsIiwiX29wdGlvbnNfc2Nyb2xsIiwicmVzZXRTY3JvbGwiLCJ1cGNvbWluZ1Njcm9sbFN0YXRlIiwidXBjb21pbmdSb3V0ZXJTdGF0ZSIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxIiwiX3JvdXRlSW5mb19wcm9wczEiLCJjYW5Ta2lwVXBkYXRpbmciLCJjb21wYXJlUm91dGVyU3RhdGVzIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJsYW5nIiwiaGFzaFJlZ2V4IiwibG9hZEVycm9yRmFpbCIsImlzQXNzZXRFcnJvciIsImdldEluaXRpYWxQcm9wcyIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwicmVxdWVzdGVkUm91dGUiLCJleGlzdGluZ0luZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJmZXRjaE5leHREYXRhUGFyYW1zIiwiZ2V0RGF0YUhyZWYiLCJza2lwSW50ZXJwb2xhdGlvbiIsIl9kYXRhX2VmZmVjdCIsIl9kYXRhX2VmZmVjdDEiLCJfZGF0YV9lZmZlY3QyIiwicmVzb2x2ZWRSb3V0ZSIsImlzQVBJUm91dGUiLCJyZXMiLCJtb2QiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ3YXNCYWlsZWRQcmVmZXRjaCIsIl9kYXRhX3Jlc3BvbnNlIiwic2hvdWxkRmV0Y2hEYXRhIiwiX2dldERhdGEiLCJmZXRjaGVkIiwiZ2V0UHJvcGVyRXJyb3IiLCJjYiIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJuZXdVcmxOb0hhc2giLCJuZXdIYXNoIiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwic2Nyb2xsVG8iLCJyYXdIYXNoIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWRFbCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidXJsUGF0aG5hbWUiLCJvcmlnaW5hbFBhdGhuYW1lIiwiX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0giLCJfaXNTc2ciLCJpc1NzZyIsInByaW9yaXR5IiwiX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFIiwibG9hZFBhZ2UiLCJjb21wb25lbnRSZXN1bHQiLCJmbiIsImN0eCIsIkFwcFRyZWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});